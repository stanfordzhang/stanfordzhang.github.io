{"meta":{"title":"Stanford","subtitle":"Stanford's Home","description":"一蓑烟雨任平生","author":"Stanford Zhang","url":"http://stanfordzhang.com"},"pages":[{"title":"关于","date":"2017-01-04T09:17:58.000Z","updated":"2017-01-04T09:24:02.000Z","comments":true,"path":"about/index.html","permalink":"http://stanfordzhang.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Introduction to Linux Zombie Process","slug":"Introduction-to-Linux-Zombie-Process","date":"2019-09-30T09:37:34.000Z","updated":"2019-09-30T10:01:38.542Z","comments":true,"path":"post/22042d32.html","link":"","permalink":"http://stanfordzhang.com/post/22042d32.html","excerpt":"概述Linux允许进程查询内核以获得其父进程的PID，或者其任何子进程的执行状态。例如，进程可以创建一个子进程来执行特定的任务，然后调用诸如wait()这样的一些库函数检查子进程是否终止。如果子进程已经终止，那么，它的终止代号将告诉父进程这个任务是否已成功地完成。为了遵循这些设计原则，不允许Linux内核在进程终止后就丢弃包含在进程描述符字段中的数据。只有父进程发出了与被终止的进程相关的wait()类系统调用之后，才允许这样做。这就是引入僵死状态的原因：尽管从技术上来说进程已死，但必须保存它的描述符，直到父进程得到通知。如果一个进程已经终止，但是它的父进程尚未调用wait()或waitpid()对它进行清理，这时的进程状态称为僵死状态，处于僵死状态的进程称为僵尸进程(Zombie Process)。任何进程在刚终止时都是僵尸进程，正常情况下，僵尸进程都立刻被父进程清理了。","text":"概述Linux允许进程查询内核以获得其父进程的PID，或者其任何子进程的执行状态。例如，进程可以创建一个子进程来执行特定的任务，然后调用诸如wait()这样的一些库函数检查子进程是否终止。如果子进程已经终止，那么，它的终止代号将告诉父进程这个任务是否已成功地完成。为了遵循这些设计原则，不允许Linux内核在进程终止后就丢弃包含在进程描述符字段中的数据。只有父进程发出了与被终止的进程相关的wait()类系统调用之后，才允许这样做。这就是引入僵死状态的原因：尽管从技术上来说进程已死，但必须保存它的描述符，直到父进程得到通知。如果一个进程已经终止，但是它的父进程尚未调用wait()或waitpid()对它进行清理，这时的进程状态称为僵死状态，处于僵死状态的进程称为僵尸进程(Zombie Process)。任何进程在刚终止时都是僵尸进程，正常情况下，僵尸进程都立刻被父进程清理了。 僵尸进程是如何产生的在UNIX系统中，一个进程结束后，但是它的父进程没有等待（调用wait/waitpid）他，那么它将变成一个僵尸进程。通过ps命令查看其带有defunct的标志。僵尸进程是一个早已死亡的进程，但在进程表（processs table）中仍占了一个位置（slot）。但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程，看看有没有哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由Init进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而Init进程会自动wait其子进程，因此被Init接管的所有进程都不会变成僵尸进程。 为了观察到僵尸进程，写一个不正常的程序，父进程fork出子进程，子进程终止，而父进程既不终止也不调用 wait 清理子进程: 12345678910111213141516171819202122232425262728// demo1.c#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int i = 100; pid_t pid=fork(); if(pid &lt; 0) &#123; perror(\"fork failed.\"); exit(1); &#125; if(pid &gt; 0) &#123; printf(\"This is the parent process. My PID is %d.\\n\", getpid()); for(; i &gt; 0; i--) &#123; sleep(1); &#125; &#125; else if(pid == 0) &#123; printf(\"This is the child process. My PID is: %d. My PPID is: %d.\\n\", getpid(), getppid()); &#125; return 0;&#125; 编译、运行、查看进程状态： 12345678910&gt; gcc demo1.c -o demo1&gt; ./demo1This is the parent process. My PID is 1718.This is the child process. My PID is: 1719. My PPID is: 1718.&gt; ps aux | grep demo1pc 2217 0.0 0.0 4504 716 pts/1 S+ 02:44 0:00 ./demo1pc 2218 0.0 0.0 0 0 pts/1 Z+ 02:44 0:00 [demo1] &lt;defunct&gt;pc 2220 0.0 0.0 23252 1148 pts/0 S+ 02:45 0:00 grep --color=auto demo1 可以看到进程PID为2218的进程状态是Z+，说明该进程处于僵死状态。 如果此时中止父进程，再查看进程列表，发现进程都不见了。这是因为当父进程退出后，子进程会变成孤儿进程，此时它会被一个管理进程收养。在不同的系统中，这个管理进程不太一样，早期一般是init进程，Ubuntu上是upstart，还有近来的Systemd。但是它们都完成相同的任务，就是wiat()这些孤儿进程，并最终释放它们占用的系统进程表中的资源。这样，这些已经僵死的孤儿进程就彻底的被清除了。 僵尸进程的危害在进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息(包括进程号PID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等)。直到父进程通过wait/waitpid来取时才释放。 如果进程不调用wait/waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。 如何处理僵尸进程僵尸进程的产生是因为父进程没有wait()子进程。所以如果我们自己写程序的话一定要在父进程中通过wait()来避免僵尸进程的产生。 当系统中出现了僵尸进程时，我们是无法通过kill命令把它清除掉的。但是我们可以杀死它的父进程，让它变成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。 下面的demo2.c中，父进程通过wait()等待子进程结束： 12345678910111213141516171819202122232425262728293031323334353637// demo2.c#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; pid_t pid; pid = fork(); if (pid &lt; 0) &#123; perror(\"fork failed\"); exit(1); &#125; if (pid == 0) &#123; int i; for (i = 3; i &gt; 0; i--) &#123; printf(\"This is the child\\n\"); sleep(1); &#125; // exit with code 3 for test. exit(3); &#125; else &#123; int stat_val; wait(&amp;stat_val); if (WIFEXITED(stat_val)) &#123; printf(\"Child exited with code %d\\n\", WEXITSTATUS(stat_val)); &#125; &#125; return 0;&#125; demo2中父进程不仅等待子进程结束，还通过WEXITSTATUS宏取到了子进程的 exit code。 参考 Linux 僵尸进程产生原因及解决方法 Linux僵尸进程","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://stanfordzhang.com/tags/Linux/"},{"name":"Zombie Process","slug":"Zombie-Process","permalink":"http://stanfordzhang.com/tags/Zombie-Process/"}]},{"title":"Introduction to C++ Global and Local Static Object's Lifecycle","slug":"Introduction-to-C-Global-and-Local-Static-Object-s-Lifecycle","date":"2019-09-30T04:29:22.000Z","updated":"2019-09-30T07:38:14.586Z","comments":true,"path":"post/e159c7f6.html","link":"","permalink":"http://stanfordzhang.com/post/e159c7f6.html","excerpt":"概述在开发C++项目时，经常会使用到全局对象，虽然不太推荐使用，但用的妙却有不一样的效果，需要慎用。本文详细介绍下C++中全局变量的生命周期。","text":"概述在开发C++项目时，经常会使用到全局对象，虽然不太推荐使用，但用的妙却有不一样的效果，需要慎用。本文详细介绍下C++中全局变量的生命周期。 预备几个PE段的说明 data段:存放在编译阶段(而非运行时)就能确定的数据,可读可写就是通常所说的静态存储区,赋了初值的全局变量和静态变量存放在这个域,常量也存放在这个区域。 .rdata段：rdata是用来存放只读实始化变量的，当我们在源程序中的变量前面加了const后，编译器知道个字符串是永远不会改变的，或说是只读的，所以将其分配到.rdata段中。 .bss段:定义而没有赋初值的全局变量和静态变量,放在这个区域 .idata：（数据段），导入函数的代码段，存放外部函数地址。 一般C语言的编译后执行语句都编译成机器代码，保存在.text段。已初始化的全局变量和局部静态变量都保存在.data段未初始化的全局变量一般放在一个叫.“bss”的段里。 全局变量和静态变量在源文件中定义： 12345static int n; //定义静态全局变量 .dataint n; // 全局变量 .dataconst int n = 0; // .rdata 区别： 全局变量是不显式用static修饰的全局变量，但全局变量默认是动态的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern全局变量名的声明，就可以使用全局变量. 全局静态变量是显式用static修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用extern声明也不能使用。 文件作用域下声明的const的常量默认为static存储类型。 认识atexit函数atexit函数的声明为： 1int atexit( void ( __cdecl *func )( void ) ); 参数为函数指针，返回值为整型，0表示成功，其他表示失败。当程序运行结束时，他调用atexit函数注册的所有函数。如果多次调用atexit函数，那么系统将以LIFO(last-in-first-out)的方式调用所有的注册函数。 MSDN示例： 123456789101112131415161718192021222324252627282930举例如下（代码摘自MSDN）：#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void fn1( void ), fn2( void ), fn3( void ), fn4( void );void main( void )&#123; atexit( fn1 ); atexit( fn2 ); atexit( fn3 ); atexit( fn4 ); printf( \"This is executed first.\\n\" );&#125;void fn1()&#123; printf( \"next.\\n\" );&#125;void fn2()&#123; printf( \"executed \" );&#125;void fn3()&#123; printf( \"is \" );&#125;void fn4()&#123; printf( \"This \" );&#125; 编译、运行程序后，程序的输出为： 12&gt; This is executed first.&gt; This is executed next. 注册函数的顺序为：fn1、fn2、fn3、fn4，但是调用顺序为fn4、fn3、fn2、fn1。 局部静态变量示例代码： 12345678910111213141516171819class Dummy&#123;public: Dummy() &#123; printf(\"Dummy\\n\"); &#125; ~Dummy() &#123; printf(\"~Dummy\\n\"); &#125;&#125;;static Dummy dummy1; // 全局静态变量int main(int argc, char* argv[])&#123; static Dummy dummy2; // 局部静态变量 printf(\"Hello world!\\n\"); return 0;&#125; 再看局部静态变量static Dummy dummy2;这一段的反汇编： 1234567891011121314static Dummy dummy2;00DE13FD mov eax,dword ptr [$S1 (0DEA140h)]00DE1402 and eax,100DE1405 jne main+79h (0DE1439h)00DE1407 mov eax,dword ptr [$S1 (0DEA140h)]00DE140C or eax,100DE140F mov dword ptr [$S1 (0DEA140h)],eax00DE1414 mov dword ptr [ebp-4],000DE141B mov ecx,offset dummy2 (0DEA144h)00DE1420 call Dummy::Dummy (0DE10C8h) // 调用构造函数00DE1425 push offset `main&apos;::`2&apos;::`dynamic atexit destructor for &apos;dummy2&apos;&apos; (0DE66E0h)00DE142A call @ILT+100(_atexit) (0DE1069h) // 将dummy2的析构函数放入atexit队列00DE142F add esp,400DE1432 mov dword ptr [ebp-4],0FFFFFFFFh 从反汇编可知，局部静态对象是在执行到对象定义的地方执行构造函数，同时将析构函数注册到main函数退出(atexit)后执行清理的队列里。参考Introduction to Visual C++ 2008 C/C++ Runtime(CRT)中的doexit部分。 全局变量或全局静态变量代码同上，对象dummy1。 构造函数调用栈： 123456789demo1.exe!Dummy::Dummy() Line 10demo1.exe!`dynamic initializer for &apos;dummy1&apos;&apos;() Line 17 + 0x28 bytesmsvcr90d.dll!_initterm(void (void)* * pfbegin=0x00de8208, void (void)* * pfend=0x00de830c) Line 903demo1.exe!__tmainCRTStartup() Line 501 + 0xf bytesdemo1.exe!mainCRTStartup() Line 403kernel32.dll!752b6359()[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]ntdll.dll!77b17b74()ntdll.dll!77b17b44() 12345678910demo1.exe!Dummy::~Dummy() Line 13demo1.exe!`dynamic atexit destructor for &apos;dummy1&apos;&apos;() + 0x28 bytesmsvcr90d.dll!doexit(int code=0, int quick=0, int retcaller=0) Line 591msvcr90d.dll!exit(int code=0) Line 412 + 0xd bytesdemo1.exe!__tmainCRTStartup() Line 599demo1.exe!mainCRTStartup() Line 403kernel32.dll!752b6359()[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]ntdll.dll!77b17b74()ntdll.dll!77b17b44() 参考Introduction to Visual C++ 2008 C/C++ Runtime(CRT)中的初始化和doexit部分。全局变量在_initterm中构造，在doexit中析构。 引用 Introduction to Visual C++ 2008 C/C++ Runtime(CRT) 静态对象、全局对象与程序的运行机制 静态全局变量和全局变量的区别","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://stanfordzhang.com/tags/C/"},{"name":"Runtime","slug":"Runtime","permalink":"http://stanfordzhang.com/tags/Runtime/"},{"name":"Global Object","slug":"Global-Object","permalink":"http://stanfordzhang.com/tags/Global-Object/"},{"name":"全局变量的生命周期","slug":"全局变量的生命周期","permalink":"http://stanfordzhang.com/tags/全局变量的生命周期/"}]},{"title":"Introduction to Visual C++ 2008 C/C++ Runtime(CRT)","slug":"Introduction-to-Visual-C-2008-C-C-Runtime-CRT","date":"2019-09-30T01:33:53.000Z","updated":"2019-09-30T10:35:14.299Z","comments":true,"path":"post/e5f87e06.html","link":"","permalink":"http://stanfordzhang.com/post/e5f87e06.html","excerpt":"概述任何一个C/C++程序，它的背后都有一套庞大的代码来进行支撑其正常运行。这套代码至少包括入口函数，及其依赖的函数所构成的函数集合。当然，它还应该包括各种标准函数（如字符串，数学运算等）的实现。本文介绍VC++ 2008运行时库实现的原理，详细剖析main函数执行前后都做了什么。","text":"概述任何一个C/C++程序，它的背后都有一套庞大的代码来进行支撑其正常运行。这套代码至少包括入口函数，及其依赖的函数所构成的函数集合。当然，它还应该包括各种标准函数（如字符串，数学运算等）的实现。本文介绍VC++ 2008运行时库实现的原理，详细剖析main函数执行前后都做了什么。 前言Visual C++ 2008 CRT代码路径 C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\crt Source Code Copy https://github.com/stanfordzhang/vc9crt.git 找到真正的入口函数使用Visual Studio 2008创建Win32 Console Application，名字叫demo1。 默认情况下Code Generation-&gt;Runtime Library-&gt;Multi-threaded Debug DLL(/MDd)这个很重要，选择不同的Runtime Library，CRT初始化代码不一样。 测试代码如下： 12345int main(int arg, char* argv[])&#123; printf(\"Hello world!\\n\"); // 只增加了这行代码 return 0;&#125; 在printf那行下一个断点，可以看到调用栈如下所示： 1234demo1.exe!main(int argc=1,char** argv=0x014d49e8) Line 9demo1.exe!__tmainCRTStartup() Line 586 + 0x19 bytesdemo1.exe!mainCRTStartup() Line 403... 由调用栈可以看到由mainCRTStartup()调用__tmainCRTStartup()再调用我们的入口_tmain函数。 mainCRTStartup()代码在crt/src/crtexe.c(Line 374 - 403)中，如下： 123456789101112131415161718192021222324252627282930#ifdef _WINMAIN_#ifdef WPRFLAGint wWinMainCRTStartup(#else /* WPRFLAG */int WinMainCRTStartup(#endif /* WPRFLAG */#else /* _WINMAIN_ */#ifdef WPRFLAGint wmainCRTStartup(#else /* WPRFLAG */int mainCRTStartup(#endif /* WPRFLAG */#endif /* _WINMAIN_ */ void )&#123; /* * The /GS security cookie must be initialized before any exception * handling targetting the current image is registered. No function * using exception handling can be called in the current image until * after __security_init_cookie has been called. */ __security_init_cookie(); return __tmainCRTStartup();&#125; mainCRTStartup()函数中在对栈溢出进行安全性检查（security_init_cookie()）后就直接调用tmainCRTStartup()。 下面再看__tmainCRTStartup()的代码，在文件crt/src/crtexe.c(Line 405 - 624)中。说明见中文注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220__declspec(noinline)int__tmainCRTStartup( void )&#123;#ifdef _WINMAIN_ _TUCHAR *lpszCommandLine; STARTUPINFO StartupInfo; BOOL inDoubleQuote=FALSE; __try &#123; /* Note: MSDN specifically notes that GetStartupInfo returns no error, and throws unspecified SEH if it fails, so the very general exception handler below is appropriate */ GetStartupInfo( &amp;StartupInfo ); &#125; __except(EXCEPTION_EXECUTE_HANDLER) &#123; return 255; &#125;#endif /* _WINMAIN_ */ /* * Guard the initialization code and the call to user's main, or * WinMain, function in a __try/__except statement. */ __try &#123; /* * There is a possiblity that the module where this object is * linked into is a mixed module. In all the cases we gurantee that * native initialization will occur before managed initialization. * Also in anycase this code should never be called when some other * code is initializing native code, that's why we exit in that case. * * Do runtime startup initializers. * * Note: the only possible entry we'll be executing here is for * __lconv_init, pulled in from charmax.obj only if the EXE was * compiled with -J. All other .CRT$XI* initializers are only * run as part of the CRT itself, and so for the CRT DLL model * are not found in the EXE. For that reason, we call _initterm, * not _initterm_e, because __lconv_init will never return failure, * and _initterm_e is not exported from the CRT DLL. * * Note further that, when using the CRT DLL, executing the * .CRT$XI* initializers is only done for an EXE, not for a DLL * using the CRT DLL. That is to make sure the -J setting for * the EXE is not overriden by that of any DLL. */ void *lock_free=0; void *fiberid=((PNT_TIB)NtCurrentTeb())-&gt;StackBase; int nested=FALSE; while((lock_free=InterlockedCompareExchangePointer((volatile PVOID *)&amp;__native_startup_lock, fiberid, 0))!=0) &#123; if(lock_free==fiberid) &#123; nested=TRUE; break; &#125; /* some other thread is running native startup/shutdown during a cctor/domain unload. Should only happen if this DLL was built using the Everett-compat loader lock fix in vcclrit.h */ /* wait for the other thread to complete init before we return */ Sleep(1000); &#125; if (__native_startup_state == __initializing) &#123; _amsg_exit( _RT_CRT_INIT_CONFLICT); &#125; else if (__native_startup_state == __uninitialized) &#123; __native_startup_state = __initializing;#ifndef _SYSCRT if (_initterm_e( __xi_a, __xi_z ) != 0) &#123; return 255; &#125;#else /* _SYSCRT */ _initterm((_PVFV *)(void *)__xi_a, (_PVFV *)(void *)__xi_z);#endif /* _SYSCRT */ &#125; else &#123; has_cctor = 1; &#125; /* * do C++ constructors (initializers) specific to this EXE */ if (__native_startup_state == __initializing) &#123; _initterm( __xc_a, __xc_z ); __native_startup_state = __initialized; &#125; _ASSERTE(__native_startup_state == __initialized); if(!nested) &#123; /* For X86, the definition of InterlockedExchangePointer wrongly causes warning C4312 */#pragma warning(push)#pragma warning(disable:4312) InterlockedExchangePointer((volatile PVOID *)&amp;__native_startup_lock, 0);#pragma warning(pop) &#125; /* * If we have any dynamically initialized __declspec(thread) * variables, then invoke their initialization for the primary * thread used to start the process, by calling __dyn_tls_init * through a callback defined in tlsdyn.obj. */ if (__dyn_tls_init_callback != NULL &amp;&amp; _IsNonwritableInCurrentImage((PBYTE)&amp;__dyn_tls_init_callback)) &#123; __dyn_tls_init_callback(NULL, DLL_THREAD_ATTACH, NULL); &#125; /* Enable buffer count checking if linking against static lib */ _CrtSetCheckCount(TRUE);#ifdef _WINMAIN_ /* * Skip past program name (first token in command line). * Check for and handle quoted program name. */#ifdef WPRFLAG /* OS may not support \"W\" flavors */ if (_wcmdln == NULL) return 255; lpszCommandLine = (wchar_t *)_wcmdln;#else /* WPRFLAG */ lpszCommandLine = (unsigned char *)_acmdln;#endif /* WPRFLAG */ while (*lpszCommandLine &gt; SPACECHAR || (*lpszCommandLine&amp;&amp;inDoubleQuote)) &#123; /* * Flip the count from 1 to 0 or 0 to 1 if current character * is DOUBLEQUOTE */ if (*lpszCommandLine==DQUOTECHAR) inDoubleQuote=!inDoubleQuote;#ifdef _MBCS if (_ismbblead(*lpszCommandLine)) &#123; if (lpszCommandLine) &#123; lpszCommandLine++; &#125; &#125;#endif /* _MBCS */ ++lpszCommandLine; &#125; /* * Skip past any white space preceeding the second token. */ while (*lpszCommandLine &amp;&amp; (*lpszCommandLine &lt;= SPACECHAR)) &#123; lpszCommandLine++; &#125;#ifdef WPRFLAG mainret = wWinMain(#else /* WPRFLAG */ mainret = WinMain(#endif /* WPRFLAG */ (HINSTANCE)&amp;__ImageBase, NULL, lpszCommandLine, StartupInfo.dwFlags &amp; STARTF_USESHOWWINDOW ? StartupInfo.wShowWindow : SW_SHOWDEFAULT );#else /* _WINMAIN_ */#ifdef WPRFLAG __winitenv = envp; mainret = wmain(argc, argv, envp);#else /* WPRFLAG */ __initenv = envp; mainret = main(argc, argv, envp);// 这里是真正的main函数入口#endif /* WPRFLAG */#endif /* _WINMAIN_ */ /* * Note that if the exe is managed app, we don't really need to * call exit or _c_exit. .cctor should be able to take care of * this. */ if ( !managedapp ) exit(mainret); if (has_cctor == 0) _cexit(); &#125; __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) ) &#123; /* * Should never reach here */ mainret = GetExceptionCode(); /* * Note that if the exe is managed app, we don't really need to * call exit or _c_exit. .cctor should be able to take care of * this. */ if ( !managedapp ) _exit(mainret); if (has_cctor == 0) _cexit(); &#125; /* end of try - except */ return mainret;&#125; 我们在__tmainCRTStartup()中找到调用main函数的地方，由上面代码可以看到，在调用main函数之前需要做不少准备工作，接下来我们一一来分析下。 调用main函数之前的初始化和之后的清理工作注意：这里只分析Console程序相关的代码，关于类似WinMain的处理过程类似，不再赘述。 提取关键代码如下： 123Line 483: _initterm_e( __xi_a, __xi_z ) // 这里会调用pre_c_init进行初始化Line 501: _initterm( __xc_a, __xc_z ) // 这里会调用pre_cpp_init进行初始化和C++全局对象的构造函数Line 597: exit(mainret) // 这里实际调用doexit()，做一些C的清理工作，同时调用全局C++对象的析构函数 pre_cpp_init()中会获取命令参数及环境变量。 函数doexit()，在crt0dat.c(Line 508 - 645)中，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138static void __cdecl doexit ( int code, int quick, int retcaller )&#123;#ifdef _DEBUG static int fExit = 0;#endif /* _DEBUG */#ifdef CRTDLL if (!retcaller &amp;&amp; check_managed_app()) &#123; /* Only if the EXE is managed then we call CorExitProcess. Native cleanup is done in .cctor of the EXE If the Exe is Native then native clean up should be done before calling (Cor)ExitProcess. */ __crtCorExitProcess(code); &#125;#endif /* CRTDLL */ _lockexit(); /* assure only 1 thread in exit path */ __TRY if (_C_Exit_Done != TRUE) &#123; _C_Termination_Done = TRUE; /* save callable exit flag (for use by terminators) */ _exitflag = (char) retcaller; /* 0 = term, !0 = callable exit */ if (!quick) &#123; /* * do _onexit/atexit() terminators * (if there are any) * * These terminators MUST be executed in reverse order (LIFO)! * * NOTE: * This code assumes that __onexitbegin points * to the first valid onexit() entry and that * __onexitend points past the last valid entry. * If __onexitbegin == __onexitend, the table * is empty and there are no routines to call. */ _PVFV * onexitbegin = (_PVFV *)_decode_pointer(__onexitbegin); if (onexitbegin) &#123; _PVFV * onexitend = (_PVFV *)_decode_pointer(__onexitend); _PVFV function_to_call = NULL; /* save the start and end for later comparison */ _PVFV * onexitbegin_saved = onexitbegin; _PVFV * onexitend_saved = onexitend; while (1) &#123; _PVFV * onexitbegin_new = NULL; _PVFV * onexitend_new = NULL; /* find the last valid function pointer to call. */ while (--onexitend &gt;= onexitbegin &amp;&amp; *onexitend == _encoded_null()) &#123; /* keep going backwards. */ &#125; if (onexitend &lt; onexitbegin) &#123; /* there are no more valid entries in the list, we are done. */ break; &#125; /* cache the function to call. */ function_to_call = (_PVFV)_decode_pointer(*onexitend); /* mark the function pointer as visited. */ *onexitend = (_PVFV)_encoded_null(); /* call the function, which can eventually change __onexitbegin and __onexitend */ (*function_to_call)(); onexitbegin_new = (_PVFV *)_decode_pointer(__onexitbegin); onexitend_new = (_PVFV *)_decode_pointer(__onexitend); if ( ( onexitbegin_saved != onexitbegin_new ) || ( onexitend_saved != onexitend_new ) ) &#123; /* reset only if either start or end has changed */ onexitbegin = onexitbegin_saved = onexitbegin_new; onexitend = onexitend_saved = onexitend_new; &#125; &#125; &#125;#ifndef CRTDLL /* * do pre-terminators */ _initterm(__xp_a, __xp_z);#endif /* CRTDLL */ &#125;#ifndef CRTDLL /* * do terminators */ _initterm(__xt_a, __xt_z);#endif /* CRTDLL */#ifdef _DEBUG /* Dump all memory leaks */ if (!fExit &amp;&amp; _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) &amp; _CRTDBG_LEAK_CHECK_DF) &#123; fExit = 1;#ifndef CRTDLL __freeCrtMemory(); _CrtDumpMemoryLeaks();#endif /* CRTDLL */ &#125;#endif /* _DEBUG */ &#125; /* return to OS or to caller */ __FINALLY if (retcaller) _unlockexit(); /* unlock the exit code path */ __END_TRY_FINALLY if (retcaller) return; _C_Exit_Done = TRUE; _unlockexit(); /* unlock the exit code path */ __crtExitProcess(code);&#125; doexit()函数中Line 360 - 421是执行C++全局对象的析构函数。 C的清理工作在_initterm(xp_a, xp_z)和_initterm(xt_a, xt_z)中。 总结 程序一开始进入mainCRTStartup，执行栈检查 执行__tmainCRTStartup，进行运行前的初始化工作 C环境初始化 C++环境初始化，获取命令参数和环境变量，执行全局C++对象的构造函数 执行main函数 执行exit函数 exit函数中执行C++环境清理工作和执行全局C++对象的析构函数 执行C环境的清理工作 引用 C++全局变量构造函数的调用 C++全局对象的构造函数以及析构函数的调用 C/C++变量的生命周期 C++中变量的作用域与生命周期 main函数执行之前都干啥了—-C/C++运行时库剖析 静态对象、全局对象与程序的运行机制 静态全局变量和全局变量的区别 CRT Initialization","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://stanfordzhang.com/tags/Windows/"},{"name":"Visual C++ 2008","slug":"Visual-C-2008","permalink":"http://stanfordzhang.com/tags/Visual-C-2008/"},{"name":"C/C++ Runtime","slug":"C-C-Runtime","permalink":"http://stanfordzhang.com/tags/C-C-Runtime/"},{"name":"CRT","slug":"CRT","permalink":"http://stanfordzhang.com/tags/CRT/"},{"name":"mainCRTStartup","slug":"mainCRTStartup","permalink":"http://stanfordzhang.com/tags/mainCRTStartup/"}]},{"title":"curl -w/--write-out","slug":"curl-w-write-out","date":"2019-06-12T10:47:56.000Z","updated":"2019-06-12T11:27:39.739Z","comments":true,"path":"post/8722713.html","link":"","permalink":"http://stanfordzhang.com/post/8722713.html","excerpt":"概述curl功能很强大，但这里只介绍一个比较实用的命令： 1-w, --write-out FORMAT Use output FORMAT after completion 这个命令用于格式化输出请求结果。在测试网络连接状况、格式化输出上非常实用。","text":"概述curl功能很强大，但这里只介绍一个比较实用的命令： 1-w, --write-out FORMAT Use output FORMAT after completion 这个命令用于格式化输出请求结果。在测试网络连接状况、格式化输出上非常实用。 详解输出格式由普通字符串和任意数量的变量组成，输出变量需要按照%{variable_name}的格式，如果需要输出%，double一下即可，即%%，同时，\\n是换行，\\r是回车，\\t是TAB。curl会用合适的值来替代输出格式中的变量，所有可用变量如下： url_effective - 最终获取的url地址，尤其是当你指定给curl的地址存在301跳转，且通过-L继续追踪的情形。 http_code - http状态码，如200成功,301转向,404未找到,500服务器错误等。(The numerical response code that was found in the last retrieved HTTP(S) or FTP(s) transfer. In 7.18.2 the alias response_code was added to show the same info.) http_connect - The numerical code that was found in the last response (from a proxy) to a curl CONNECT request. (Added in 7.12.4) time_total - 总时间，按秒计。精确到小数点后三位。 （The total time, in seconds, that the full operation lasted. The time will be displayed with millisecond resolution.） time_namelookup - DNS解析时间,从请求开始到DNS解析完毕所用时间。(The time, in seconds, it took from the start until the name resolving was completed.) time_connect - 连接时间,从开始到建立TCP连接完成所用时间,包括前边DNS解析时间，如果需要单纯的得到连接时间，用这个time_connect时间减去前边time_namelookup时间。以下同理，不再赘述。(The time, in seconds, it took from the start until the TCP connect to the remote host (or proxy) was completed.) time_appconnect - 连接建立完成时间，如SSL/SSH等建立连接或者完成三次握手时间。(The time, in seconds, it took from the start until the SSL/SSH/etc connect/handshake to the remote host was completed. (Added in 7.19.0)) time_pretransfer - 从开始到准备传输的时间。(The time, in seconds, it took from the start until the file transfer was just about to begin. This includes all pre-transfer commands and negotiations that are specific to the particular protocol(s) involved.) time_redirect - 重定向时间，包括到最后一次传输前的几次重定向的DNS解析，连接，预传输，传输时间。(The time, in seconds, it took for all redirection steps include name lookup, connect, pretransfer and transfer before the final transaction was started. time_redirect shows the complete execution time for multiple redirections. (Added in 7.12.3)) time_starttransfer - 开始传输时间。在发出请求之后，Web 服务器返回数据的第一个字节所用的时间(The time, in seconds, it took from the start until the first byte was just about to be transferred. This includes time_pretransfer and also the time the server needed to calculate the result.) size_download - 下载大小。(The total amount of bytes that were downloaded.) size_upload - 上传大小。(The total amount of bytes that were uploaded.) size_header - 下载的header的大小(The total amount of bytes of the downloaded headers.) size_request - 请求的大小。(The total amount of bytes that were sent in the HTTP request.) speed_download - 下载速度，单位-字节每秒。(The average download speed that curl measured for the complete download. Bytes per second.) speed_upload - 上传速度,单位-字节每秒。(The average upload speed that curl measured for the complete upload. Bytes per second.) content_type - 就是content-Type，不用多说了，这是一个访问我博客首页返回的结果示例(text/html; charset=UTF-8)；(The Content-Type of the requested document, if there was any.) num_connects - Number of new connects made in the recent transfer. (Added in 7.12.3) num_redirects - Number of redirects that were followed in the request. (Added in 7.12.3) redirect_url - When a HTTP request was made without -L to follow redirects, this variable will show the actual URL a redirect would take you to. (Added in 7.18.2) ftp_entry_path - The initial path libcurl ended up in when logging on to the remote FTP server. (Added in 7.15.4) ssl_verify_result - ssl认证结果，返回0表示认证成功。( The result of the SSL peer certificate verification that was requested. 0 means the verification was successful. (Added in 7.19.0)) 注意： 若多次使用-w参数，按最后一个的格式输出。 在使用上面变量的时候，注意看后面小括号中的 Added in XXX，这个表示支持该变量curl所需的最低版本，查看curl版本使用curl -V。如果版本不够，curl会提示类似下面的错误。 1curl: unknown --write-out variable: 'redirect_url' curl -w举例检查一批URL的HTTP状态：cat url.txt|while read line; do curl -I $line -m 5 –connect-timeout 5 -o /dev/null -s -w “$line “%{http_code}”\\n”; done&gt;ok.txt 取URL返回状态码：curl -s -m 10 -o /dev/null -w %{http_code} https://www.baidu.com References curl -w,–write-out参数详解 Linux curl命令详解","categories":[],"tags":[]},{"title":"Flutter Development References","slug":"Flutter-Development-References","date":"2019-06-09T07:34:36.000Z","updated":"2019-06-11T10:46:13.384Z","comments":true,"path":"post/6bd6334f.html","link":"","permalink":"http://stanfordzhang.com/post/6bd6334f.html","excerpt":"","text":"Dart编程语言中文网 发布Android版APP Flutter】修改图标、应用名称、包名等 Flutter实战 Flutter中文网 FLUTTER WEB环境变量搭建及开发 flutter-desktop-embedding","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://stanfordzhang.com/tags/Flutter/"},{"name":"Dart","slug":"Dart","permalink":"http://stanfordzhang.com/tags/Dart/"},{"name":"Android","slug":"Android","permalink":"http://stanfordzhang.com/tags/Android/"}]},{"title":"Use protobuf in Flutter","slug":"Use-protobuf-in-Flutter","date":"2019-06-08T10:44:40.000Z","updated":"2019-06-08T11:06:31.102Z","comments":true,"path":"post/642e1725.html","link":"","permalink":"http://stanfordzhang.com/post/642e1725.html","excerpt":"概述在Flutter项目中使用protobuf，macOS上环境配置及Flutter工程配置。","text":"概述在Flutter项目中使用protobuf，macOS上环境配置及Flutter工程配置。 步骤下载protobuf：https://github.com/protocolbuffers/protobuf/releases这里以protoc-3.8.0-osx-x86_64.zip为例或者： 1brew install protobuf 安装dart 12brew tap dart-lang/dartbrew install dart dart安装好后，就有pub命令了。 安装protoc_plugin 1pub global activate protoc_plugin 这个protoc_plugin一定要安装，protoc默认不支持dart.将protoc-gen-dart添加到path在~/.bash_profile或~/.zshrc添加 1export \"$PATH:$PWD/.pub-cache/bin\" 如果没有添加到PATH也可以在protoc参数是增加 1protoc --dart_out=. test.proto --plugin ~/.pub-cache/bin/protoc-gen-dart 安装好后，就有protoc-gen-dart命令了。如果没有安装以上工具，使用–dart_out编译时会报错 12protoc-gen-dart: program not found or is not executable--dart_out: protoc-gen-dart: Plugin failed with status code 1. 在Flutter项目中引入protobuf库 在pubspec.ymal中添加以下依赖 1protobuf: ^0.13.12 在编译官方示例过程addressbook.proto过程，如果报错找不到google/protobuf/timestamp.pb.dart则需要单独编译下载包里的protoc-3.8.0-osx-x86_64/include/google/protobuf/timestamp.proto 1protoc -I=~/Downloads/protoc-3.8.0-osx-x86_64/include/ --dart_out=. google/protobuf/timestamp.proto 如果缺少其他文件，可类似处理。 Reference 在Flutter中使用protobuf","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://stanfordzhang.com/tags/Flutter/"},{"name":"protobuf","slug":"protobuf","permalink":"http://stanfordzhang.com/tags/protobuf/"}]},{"title":"Tomcat内存溢出解决办法","slug":"Tomcat内存溢出解决办法","date":"2019-06-07T09:52:18.000Z","updated":"2019-06-07T09:59:15.239Z","comments":true,"path":"post/c5ce665c.html","link":"","permalink":"http://stanfordzhang.com/post/c5ce665c.html","excerpt":"概述常见的tomcat 内存溢出有下面三种情况： OutOfMemoryError： Java heap space OutOfMemoryError： PermGen space OutOfMemoryError： unable to create new native thread","text":"概述常见的tomcat 内存溢出有下面三种情况： OutOfMemoryError： Java heap space OutOfMemoryError： PermGen space OutOfMemoryError： unable to create new native thread NEXT主题添加Google AdSensejvm参数知道：-Xms：初始值-Xmn：最小值-Xmx：最大值 linux 配置在catalina.sh 中，找到cygwin=false 行，在它上面 加上下面的一段代码： JAVA_OPTS=”-Xms1024m -Xmx1024m”JAVA_OPTS=”$JAVA_OPTS -server -XX:PermSize=512m -XX:MaxPermSize=512m” window 配置在catalina.bat中找到 setlocal ，在其上面 加上下面的代码： set JAVA_OPTS=-server -Xms1024m -Xmx2048m -XX:PermSize=512m -XX:MaxPermSize=2048m 参数说明：-server:一定要作为第一个参数，在多个CPU时性能佳-Xms：初始Heap大小，使用的最小内存,cpu性能高时此值应设的大一些-Xmx：Java heap最大值，使用的最大内存-XX:PermSize:设定内存的永久保存区域-XX:MaxPermSize:设定最大内存的永久保存区域-XX:MaxNewSize:+XX:AggressiveHeap 会使得 Xms没有意义。这个参数让jvm忽略Xmx参数,疯狂地吃完一个G物理内存,再吃尽一个G的swap。-Xss：每个线程的Stack大小-verbose:gc 现实垃圾收集信息-Xloggc:gc.log 指定垃圾收集日志文件-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一-XX:+UseParNewGC ：缩短minor收集的时间-XX:+UseConcMarkSweepGC ：缩短major收集的时间 提示：此选项在Heap Size 比较大而且Major收集时间较长的情况下使用更合适 * 注意，linux下有单引号，win下不用，如果加上单引号，tomcat根本起不来。 Reference 解决 tomcat 内存溢出解决的办法","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://stanfordzhang.com/tags/Java/"}]},{"title":"Hexo博客添加Google AdSense","slug":"Add Google AdSense to Hexo with NEXT theme","date":"2019-05-21T08:13:30.000Z","updated":"2019-06-08T10:49:05.253Z","comments":true,"path":"post/3a06bb38.html","link":"","permalink":"http://stanfordzhang.com/post/3a06bb38.html","excerpt":"概述主要内容包括： Hexo博客，使用hexo-theme-next主题，添加Google AdSense。 添加ads.txt SEO优化之title SEO优化之添加robots.txt SEO优化之添加sitemap SEO优化之配置Google Search Console","text":"概述主要内容包括： Hexo博客，使用hexo-theme-next主题，添加Google AdSense。 添加ads.txt SEO优化之title SEO优化之添加robots.txt SEO优化之添加sitemap SEO优化之配置Google Search Console NEXT主题添加Google AdSense 参考[1][2] 注册Google AdSense账号，方法请自行搜索 注册完账号后，将AdSense里的JavaSrcipt脚本添加至NEXT主题模板里 新建 themes/next/layout/_custom/google_adsense.swig，将 AdSense 上的JavaScript代码粘贴进去 编辑 themes/hexo-theme-next/layout/_layout.swig 文件，在head元素里增加如下代码： 123&lt;!-- Google AdSense start --&gt;&#123;% include '_custom/google_adsense.swig' %&#125;&lt;!-- Google AdSense end --&gt; 添加ads.txt 参考[3][4] 授权数字卖方 (ads.txt) 是一项 IAB 计划，可帮助确保您的数字广告资源只通过您认定为已获得授权的卖家（如 AdSense）销售。创建自己的 ads.txt 文件后，您可以更好地掌控允许谁在您的网站上销售广告，并可防止向广告客户展示仿冒广告资源。添加方法参考[3][4]。 SEO优化之title 参考[5] 1&#123;% block title %&#125;&#123;&#123; title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;&#123;% if theme.index_with_subtitle and subtitle %&#125; – &#123;&#123; subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; 在themes/hexo-theme-next/layout/index.swig文件里的title内添加，也可以是其他的关键字，更有利于详细的描述网站，便于搜索引擎推荐。 SEO优化之添加robots.txt 参考[5] SEO优化之添加sitemap 参考[5] SEO优化之配置Google Search Console 参考[6][7] 参考文章中是老版本Search Console，这里使用新版本。网址：https://www.google.com/webmasters/ 在添加资源过程中有两种方式，如图所示： 图中左侧是新方法，但我没有测试成功，大概原因是Github Pages是使用CNAME来绑定域名的。本例使用右侧的老方法，输入域名之后，会下载一个html文件放在网站根目录，所下图所示：这个html是不需要渲染的，所以在_config.xml文件中配置skip_render，添加下载的html文件。验证通过后，进入Search Console，可以添加Sitemap、URL检查等操作，参考[7]。 FAQ 参考[9][10][11] Reference Hexo博客添加Google AdSense hexo 中加入 AdSense 广告服务的方法 使用 ads.txt 声明授权卖方 查找发布商 ID Hexo网站优化之SEO Hexo Seo优化让你的博客在google搜索排名第一 Google Search Console验证您的网站所有权 Hexo博客Next主题SEO优化方法 hexo链接持久化终极解决之道 Hexo渲染时排除部分文件或目录 Hexo版本升级和Next主题升级之坑","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://stanfordzhang.com/tags/Hexo/"},{"name":"hexo theme next","slug":"hexo-theme-next","permalink":"http://stanfordzhang.com/tags/hexo-theme-next/"},{"name":"Google AdSense","slug":"Google-AdSense","permalink":"http://stanfordzhang.com/tags/Google-AdSense/"},{"name":"SEO","slug":"SEO","permalink":"http://stanfordzhang.com/tags/SEO/"},{"name":"Google Search Console","slug":"Google-Search-Console","permalink":"http://stanfordzhang.com/tags/Google-Search-Console/"}]},{"title":"Install Nessus on Kali Linux","slug":"Install Nessus on Kali Linux","date":"2018-05-21T11:46:21.000Z","updated":"2019-06-07T09:21:35.491Z","comments":true,"path":"post/e8fcbb5.html","link":"","permalink":"http://stanfordzhang.com/post/e8fcbb5.html","excerpt":"Nessus是什么？ Nessus号称是世界上最流行的漏洞扫描程序，全世界有超过75000个组织在使用它。该工具提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。Nessus不同于传统的漏洞扫描软件，Nessus可同时在本机或远程操作，进行系统的漏洞分析扫描。","text":"Nessus是什么？ Nessus号称是世界上最流行的漏洞扫描程序，全世界有超过75000个组织在使用它。该工具提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。Nessus不同于传统的漏洞扫描软件，Nessus可同时在本机或远程操作，进行系统的漏洞分析扫描。 下载并安装根据不同的OS下载不同的版本，Kali Linux下载debian 6版本的Nessus。 https://www.tenable.com/downloads/nessus 安装命令： 123456789101112root@kali:~/Documents# dpkg -i Nessus-7.1.0-debian6_amd64.debSelecting previously unselected package nessus.(Reading database ... 335227 files and directories currently installed.)Preparing to unpack Nessus-7.1.0-debian6_amd64.deb ...Unpacking nessus (7.1.0) ...Setting up nessus (7.1.0) ...Unpacking Nessus Core Components... - You can start Nessus by typing /etc/init.d/nessusd start - Then go to https://kali:8834/ to configure your scannerProcessing triggers for systemd (238-4) ... 显示到这里就安装成功了！ 启动Nessus 1/etc/init.d/nessusd start 激活注册领取免费版本的激活码，领取之后会发送到邮件，注意查看邮箱。 https://www.tenable.com/products/nessus/activation-code 使用激活码激活 1/opt/nessus/sbin/nessuscli fetch --register 0BB7-F54A-60D7-FCE7-976E 激活过程中会下载安装Plugins，稍作等待。 添加账号这里都使用默认配置： 123456789101112131415161718192021root@kali:~/Documents# /opt/nessus/sbin/nessuscli adduser root[Mon May 21 06:42:52 2018][2752.1] _qdb_open:/opt/nessus/var/nessus/plugins-desc.db: Invalid table of contentsLogin password:Login password (again):Do you want this user to be a Nessus 'system administrator' user (can upload plugins, etc.)? (y/n) [n]: yUser rules----------nessusd has a rules system which allows you to restrict the hoststhat root has the right to test. For instance, you may wanthim to be able to scan his own host only.Please see the Nessus Command Line Reference for the rules syntaxEnter the rules for this user, and enter a BLANK LINE once you are done :(the user can have an empty rules set)Login : rootPassword : ***********This user will have 'system administrator' privileges within the Nessus serverIs that ok? (y/n) [n]: yUser added 访问控制界面重启Nessus服务 1/etc/init.d/nessusd restart 打开浏览器访问，默认端口是8834。 https://10.98.53.137:8834 References 《Kali Linux渗透测试技术详解》","categories":[],"tags":[{"name":"Kali Linux","slug":"Kali-Linux","permalink":"http://stanfordzhang.com/tags/Kali-Linux/"},{"name":"Nessus","slug":"Nessus","permalink":"http://stanfordzhang.com/tags/Nessus/"},{"name":"Security","slug":"Security","permalink":"http://stanfordzhang.com/tags/Security/"}]},{"title":"XCode设置Build Number自增","slug":"XCode设置Build-Number自增","date":"2017-11-30T09:46:21.000Z","updated":"2019-06-07T09:21:35.497Z","comments":true,"path":"post/c7253149.html","link":"","permalink":"http://stanfordzhang.com/post/c7253149.html","excerpt":"CocoaPods是什么？ 在提交iOS应用时，相同的Build Number是无法重复上传的。如果每次都要手动修改版本号，比较低效和容易出错。所以这里介绍一种自动增加Build Number的方法。","text":"CocoaPods是什么？ 在提交iOS应用时，相同的Build Number是无法重复上传的。如果每次都要手动修改版本号，比较低效和容易出错。所以这里介绍一种自动增加Build Number的方法。 References https://crunchybagel.com/auto-incrementing-build-numbers-in-xcode/","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"},{"name":"iOS","slug":"iOS","permalink":"http://stanfordzhang.com/tags/iOS/"},{"name":"XCode","slug":"XCode","permalink":"http://stanfordzhang.com/tags/XCode/"}]},{"title":"macOS设置不在Dock上显示App图标","slug":"macOS设置不在Dock上显示App图标","date":"2016-10-09T08:43:30.000Z","updated":"2019-06-07T09:21:35.499Z","comments":true,"path":"post/a4b8d061.html","link":"","permalink":"http://stanfordzhang.com/post/a4b8d061.html","excerpt":"","text":"在Info.Plist里设置：LSUIElement是以Agent的方法启动。不在Dock上显示图标，但会显示窗口。LSBackgroundOnly变成后台进程，不在Dock上显示图标，也不会显示窗口。 TransformProcessType[NSApp setActivationPolicy: NSApplicationActivationPolicyAccessory];以上两个没有研究。 Reference: https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/20001431-113253 http://stackoverflow.com/questions/6796028/start-a-gui-process-in-mac-os-x-without-dock-icon/9220840 http://stackoverflow.com/questions/620841/how-to-hide-the-dock-icon","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"Git代理设置（macOS）","slug":"Git代理设置（macOS）","date":"2016-08-29T08:41:50.000Z","updated":"2019-06-07T09:21:35.489Z","comments":true,"path":"post/175d5c0d.html","link":"","permalink":"http://stanfordzhang.com/post/175d5c0d.html","excerpt":"","text":"最近要在https://chromium.googlesource.com/ Checkout点代码，但该网站被GFW墙了。无奈只能走野路子。 使用socks5通道： 首先通过如下命令登录一台未被墙的服务器： ssh root@IP地址或域名 -D 端口修改Git的配置（~/.gitconfig），新增如下行： [http]proxy = socks5://127.0.0.1:\b端口这样Git将走代理通道。 Reference:1：为Git配置代理","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"iOS/macOS签名证书类型","slug":"iOS-macOS签名证书类型","date":"2016-08-24T08:38:26.000Z","updated":"2019-06-07T09:21:35.498Z","comments":true,"path":"post/a8003ca5.html","link":"","permalink":"http://stanfordzhang.com/post/a8003ca5.html","excerpt":"","text":"Reference https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/AppDistributionGuide/MaintainingCertificates/MaintainingCertificates.html#//apple_ref/doc/uid/TP40012582-CH31-SW41 http://stackoverflow.com/questions/13196291/difference-between-mac-developer-and-3rd-party-mac-developer-application","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"},{"name":"iOS","slug":"iOS","permalink":"http://stanfordzhang.com/tags/iOS/"}]},{"title":"Kali Linux 2016.1 中科大源","slug":"Kali-Linux-2016-1-中科大源","date":"2016-08-22T08:35:41.000Z","updated":"2019-06-07T09:21:35.490Z","comments":true,"path":"post/ab7afda6.html","link":"","permalink":"http://stanfordzhang.com/post/ab7afda6.html","excerpt":"","text":"修改 /etc/apt/sources.list1234#kali官方源deb http://http.kali.org/kali kali-rolling main non-free contrib#中科大的源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib 依次执行下面命令：123apt-get update &amp; apt-get upgradeapt-get dist-upgradereboot","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://stanfordzhang.com/tags/随笔/"}]},{"title":"How To Set Up SSH Tunneling on a VPS","slug":"How-To-Set-Up-SSH-Tunneling-on-a-VPS","date":"2016-06-01T08:34:03.000Z","updated":"2019-06-07T09:21:35.489Z","comments":true,"path":"post/26d5a5c1.html","link":"","permalink":"http://stanfordzhang.com/post/26d5a5c1.html","excerpt":"","text":"How To Set Up SSH Tunneling on a VPS使用SSH隧道进行翻墙。 ##Reference: https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-tunneling-on-a-vps","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://stanfordzhang.com/tags/随笔/"}]},{"title":"Mac OS X快速安装Apache Thrift","slug":"Mac-OS-X快速安装Apache-Thrift","date":"2016-05-26T10:55:07.000Z","updated":"2019-06-07T09:21:35.495Z","comments":true,"path":"post/c2cdf3b4.html","link":"","permalink":"http://stanfordzhang.com/post/c2cdf3b4.html","excerpt":"介绍Thrift 最初由Facebook开发，而后捐献给Apache，目前已广泛应用于业界。Thrift 正如其官方主页介绍的，“是一种可扩展、跨语言的服务开发框架”。简而言之，它主要用于各个服务之间的RPC通信，其服务端和客户端可以用不同的语言来开发。只需要依照IDL（Interface Description Language）定义一次接口，Thrift工具就能自动生成 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml等语言的代码。","text":"介绍Thrift 最初由Facebook开发，而后捐献给Apache，目前已广泛应用于业界。Thrift 正如其官方主页介绍的，“是一种可扩展、跨语言的服务开发框架”。简而言之，它主要用于各个服务之间的RPC通信，其服务端和客户端可以用不同的语言来开发。只需要依照IDL（Interface Description Language）定义一次接口，Thrift工具就能自动生成 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml等语言的代码。 安装Thrift的安装还是有些繁琐的，跟着官方文档的走就可以。如果你是Mac OS X， 这里有更方便的方法。brew install boostbrew install libeventbrew install thriftgem install thrift – –with-cppflags=’-D_FORTIFY_SOURCE=0’ 不过注意上述方法默认安装的最新版。 QAError: The brew link step did not complete successfullyThe formula built, but is not symlinked into /usr/localYou can try again using `brew link thrift’ 如果报以上错误，再手动运行：brew link thrift 即可。 * Reference https://wuchong.me/blog/2015/10/07/thrift-induction/ https://diwakergupta.github.io/thrift-missing-guide/ http://thrift-tutorial.readthedocs.io/en/latest/index.html http://www.jianshu.com/p/0f4113d6ec4b","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"Linux/OSX 命令输入操作快捷键","slug":"Linux-OSX-命令输入操作快捷键","date":"2016-05-17T10:54:26.000Z","updated":"2019-06-07T09:21:35.492Z","comments":true,"path":"post/1f6fd35e.html","link":"","permalink":"http://stanfordzhang.com/post/1f6fd35e.html","excerpt":"","text":"ctrl + w —往回删除一个单词，光标放在最末尾ctrl + k —往前删除到末尾，光标放在最前面（可以使用ctrl+a）ctl + u 删除光标以前的字符ctl + k 删除光标以后的字符ctl + a 移动光标至的字符头ctl + e 移动光标至的字符尾ctl + l 清屏 ctrl + r命令历史，继续按这个快捷键可以向前翻","categories":[],"tags":[]},{"title":"Linux/OSX 统计文件个数命令","slug":"Linux-OSX-统计文件个数命令","date":"2016-05-17T10:52:28.000Z","updated":"2019-06-07T09:21:35.493Z","comments":true,"path":"post/4a20c7a3.html","link":"","permalink":"http://stanfordzhang.com/post/4a20c7a3.html","excerpt":"","text":"命令如下：1find &lt;目录&gt; -type f | wc -l 根据目录路径，显示文件个数，不包括目录。 例如：统计全盘文件个数：1find / -type f | wc -l","categories":[],"tags":[]},{"title":"Mac OS X 快速复制（拷贝）文件（夹）路径","slug":"Mac-OS-X-快速复制（拷贝）文件（夹）路径","date":"2016-04-13T14:17:02.000Z","updated":"2019-06-07T09:21:35.494Z","comments":true,"path":"post/e3989891.html","link":"","permalink":"http://stanfordzhang.com/post/e3989891.html","excerpt":"在使用Mac OS X的\b过程中，如果有一个文件所在的目录层次很深，想要拷贝文件路径是麻烦事儿。本文介绍一种通过Finder右键菜单项来复制文件路径的方法，如果哪个朋友有更好的方法麻烦告知，在此谢过！","text":"在使用Mac OS X的\b过程中，如果有一个文件所在的目录层次很深，想要拷贝文件路径是麻烦事儿。本文介绍一种通过Finder右键菜单项来复制文件路径的方法，如果哪个朋友有更好的方法麻烦告知，在此谢过！ 在Launchpad里启动Automator。 创建一个新的服务（Service）。选项如下图所示： \b最后保存为Copy Path： \b 这样就完成了Finder右键菜单项的制作，试试吧~ Reference: http://osxdaily.com/2013/06/19/copy-file-folder-path-mac-os-x/","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"CocoaPods安装和使用教程","slug":"CocoaPods安装和使用教程","date":"2016-04-12T14:14:00.000Z","updated":"2019-06-07T09:21:35.488Z","comments":true,"path":"post/902b1754.html","link":"","permalink":"http://stanfordzhang.com/post/902b1754.html","excerpt":"CocoaPods是什么？ 通常在开发iOS/OSX应用时，经常使用到一些第三方开源库，比如JSONKit，AFNetWorking，OpenSSL，Boost等。这些库下载、版本更新管理相当麻烦和费时，尤其是C/C++相关库，还需要编译，编译时还有各种各样的库依赖。那有没有类似于Python中的PIP/easy_install这样的包（库）管理工具呢？ 本文将介绍一个开发iOS/OSX时经常用到的包管理工具CocoaPods。 官方网址：https://cocoapods.org/","text":"CocoaPods是什么？ 通常在开发iOS/OSX应用时，经常使用到一些第三方开源库，比如JSONKit，AFNetWorking，OpenSSL，Boost等。这些库下载、版本更新管理相当麻烦和费时，尤其是C/C++相关库，还需要编译，编译时还有各种各样的库依赖。那有没有类似于Python中的PIP/easy_install这样的包（库）管理工具呢？ 本文将介绍一个开发iOS/OSX时经常用到的包管理工具CocoaPods。 官方网址：https://cocoapods.org/ 安装CocoaPods安装CocoaPods，需要使用Ruby环境，通常Mac OS X已经自带Ruby。在终端下运行如下命令： 1$ sudo gem install cocoapods 安装失败？是的，因为默认安装源被GFW了。这里需要更改成淘宝的源： 12gem sources --remove https://rubygems.org/ // 删除原来的gem sources -a https://ruby.taobao.org/ // 增加淘宝的源，这里注意淘宝已经废弃http的源，统一成了https 查看源： 12345gem sources -l *** CURRENT SOURCES *** https://ruby.taobao.org/ 现在执行： 1sudo gem install cocoapods 等一会，是不是安装成功了~ 使用CocoaPods首先搜索需要使用的库是否支持CocoaPods（这里以AFNetworking为例）： 这里可以看到很多个带有AFNetworking关键字的库，第一个是我们要找的。 接下来创建一个示例工程pod_demo，同时在工程文件pod_demo.xcodeproj同一目录下创建Podfile文本文件： 并输入如下内容： 12platform :osx, '10.9'pod 'AFNetworking', '~&gt; 2.6.3' 第一行解释： 因为示例工程是OSX平台的，所有platform是osx版本。如果是用于iOS，Platform是可以写成： 1platform :ios, '8.0' 在安装过程中会检测当前库版本是否适用于指定的系统版本，如果不适用，会报如下异常： \b不同的AFNetworking对应不同的系统版本【2】：\b第二行解释：‘&gt; 0.1’ 大于0.1的版本‘&gt;= 0.1’ 大于等于0.1的版本‘&lt; 0.1’ 小于0.1的版本‘&lt;= 0.1’ 小于等于0.1的版本‘~&gt; 0.1.2’ 0.1.2到0.2之间的版本，不包括0.2及\b更高版本‘~&gt; 0.1’ 0.1到1.0之间的版本，不包括1.0及更高版本‘~&gt; 0’ 0及更高版本，相当于所有版本 接下来终端切换到Podfile所在目录，安装库： 1pod install 这时你会发现目录下多了几个文件（夹）：pod_demo.xcworkspace、Podfile.lock、Pods，这些都是CocoaPods生成的。目录结构如下： \b\b上图是安装成功界面，请注意最后绿字那一行：关闭XCode，并打开pod_demo.xcworkspace。这时用XCode打开pod_demo.xcworkspace，在代码中就能正常使用AFNetworing库了。 注：使用CocoaPods安装库后，要打开xcworkspace而不是xcodeproj了。## 补充内容如果已经有Podfile，需要更新新版本，使用：1pod update Reference:https://cocoapods.org/https://github.com/AFNetworking/AFNetworking","categories":[],"tags":[]},{"title":"Mac OS X上开发和使用动态链接库/dylib/共享库","slug":"Mac-OS-X上开发和使用动态链接库-dylib-共享库","date":"2016-04-11T13:48:13.000Z","updated":"2019-06-07T09:21:35.496Z","comments":true,"path":"post/9a8573bf.html","link":"","permalink":"http://stanfordzhang.com/post/9a8573bf.html","excerpt":"在OS X上开发应用通常会用到dylib动态链接库，使用XCode开发及调用一个dylib还是比较容易的，通常的做法使用dlopen（类似于Windows上的LoadLibrary）加载dylib，使用dlsym（类似GetProcAddress）找到导出接口，然后调用，最后dlclose（类似FreeLibrary）之即可。这个方法和Linux上使用共享库的方式是一样的，这里就不作介绍了。 本文介绍一种更加方便的方法，通过设置几个编译选项，运行时系统自动加载dylib，使用时只需要调用即可。以下是示例步骤。","text":"在OS X上开发应用通常会用到dylib动态链接库，使用XCode开发及调用一个dylib还是比较容易的，通常的做法使用dlopen（类似于Windows上的LoadLibrary）加载dylib，使用dlsym（类似GetProcAddress）找到导出接口，然后调用，最后dlclose（类似FreeLibrary）之即可。这个方法和Linux上使用共享库的方式是一样的，这里就不作介绍了。 本文介绍一种更加方便的方法，通过设置几个编译选项，运行时系统自动加载dylib，使用时只需要调用即可。以下是示例步骤。 一、创建dylib工程创建dylib工程dylib_demo。 二、参数选择这里以导出C++类接口为例。 三、配置编译选项可以在dylib的Build Phases里看到Installataion Diectory（INSTALL_PATH）这个选项，默认是/usr/local/lib。这个意思是指可执行程序在自动加载时去哪里找这个dylib。可以使用otool进行查看（如下图）。 第一行显示的就是dylib所在的路径：/usr/local/lib/libdylib_demo.dylib。这是系统目录，调用程序会去这个目录找。如果不把dylib拷贝到这个目录，程序将无法运行。发布一个程序时，还要将自用库拷贝到系统目录？这是不合理的。 这里将Installation Directory改成@loader_path/../Frameworks，以相对目录查找dylib。下图是otool显示。@loader_path的意思相对load这个dylib的模块所在的路径找dylib所在的目录。 Installation Directory (INSTALL_PATH) 详解： @executable_path 表示可执行程序所在的目录. 比如 /path/foo.app/Contents/MacOS/。 @loader_path 表示每一个被加载的 binary（包括App, dylib, framework等）所在的目录。 @rpath 和前面两个不同, 它只是一个保存着一个或多个路径的变量。在 app中设置 Runpath Search Paths（对应了@rpath）。 四、创建调用app创建名为caller_demo的app。 参数设置 五、设置链接到dylib在app的Build Phases的Link Binary With Libraries里增加刚刚创建的dylib。 如果列表里没有点击右下角的Add Other在目录里找。 也可以在Finder里拖拽dylib到Link Binary With Libraries里。 六、拷贝dylib至目标目录这里app包结构包结构里还没有这个dylib，运行时还是找不着。在Build Phases里点加号，新增Copy Files Phase，将dylib拷贝到Frameworks目录下，以便loader可以找到。 这里为什么是Frameworks目录，是因为设置INSTALL_PATH为@loader_path/../Frameworks。 也可以设置为其他目录，比如INSTALL_PATH为@loader_path/../dll，那Copy Files时，就要放到dll目录，如果下拉列表没有相应目录，可以下拉选Frameworks，然后在Subpath里填../dll这个相对路径，XCode会自动创建一个Frameworks同级目录dll。 \b \b \b 七、调用比如在AppDelegate.m文件里调用，因为是使用C++类，所以要将文件扩展名改为.mm，如果是使用标准C、ObjC接口，则不用改。 八、结语可以看到，以上方法使用比较方便，在开发过程中配置好XCode，一键编译。 调用时可以像静态库一样使用，省时省力。 Reference: http://www.tanhao.me/pieces/1361.html/ https://wincent.com/wiki/@executable_path,_@load_path_and_@rpath","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"基于腾讯云自建Blog-WordPress+CentOS+Nginx","slug":"基于腾讯云自建Blog-WordPress-CentOS-Nginx","date":"2016-04-07T13:13:30.000Z","updated":"2019-06-07T09:21:35.500Z","comments":true,"path":"post/99172a83.html","link":"","permalink":"http://stanfordzhang.com/post/99172a83.html","excerpt":"","text":"搭建步骤 申请云服务器 设置云服务器安装组，打开80端口。如果要访问安装在云服务器的MySQL，还要打开3306端口； 参考【1】安装Nginx/MySQL/PHP。如果使用香港云数据库CDB，无法在外网登录管理； 参考【2】安装WordPress； 因为GWF的原因，基于WordPress的网站加载比较慢，这里推荐两个插件： Google字体相关：Useso take over Google（重定向到360网站卫士的镜像）； Gravatar相关：WP-DuoShuo-Gravatar（重写向到多说的镜像）。 固定链接设置【3】。如果是使用默认固定链接，可以不设置。 接下来就可以愉快的写作了。 Reference: 软件安装：https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-on-centos-6 WordPress安装：https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-nginx-on-centos-6–2 固定链接设置：http://nginxlibrary.com/wordpress-permalinks/","categories":[],"tags":[]}]}