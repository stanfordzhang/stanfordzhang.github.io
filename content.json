{"meta":{"title":"Stanford","subtitle":"Stanford's Home","description":"一蓑烟雨任平生","author":"Stanford Zhang","url":"http://stanfordzhang.com"},"pages":[{"title":"关于","date":"2017-01-04T09:17:58.000Z","updated":"2017-01-04T09:24:02.000Z","comments":true,"path":"about/index.html","permalink":"http://stanfordzhang.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"191226-Windows Inject Dll","slug":"191226-Windows-Inject-Dll","date":"2019-12-26T07:40:46.000Z","updated":"2019-12-26T07:45:52.914Z","comments":true,"path":"post/7e4acaa9.html","link":"","permalink":"http://stanfordzhang.com/post/7e4acaa9.html","excerpt":"概述Windows Dll/代码注入在病毒、木马、游戏外挂、安全软件等场景中应用很广泛。","text":"概述Windows Dll/代码注入在病毒、木马、游戏外挂、安全软件等场景中应用很广泛。 Dll注入方法1.修改注册表 修改HKEY_LOCAL_MACHINE/Software/Microsoft/WindowsNT/CurrentVersion/Windows/AppInit_DLLs的键值，改为待注入DLL的路径，这样一来，程序运行后只要加载了user32.dll，都会加载我们写入的DLL。 2.全局消息钩子注入 Windows应用程序是基于消息驱动的，任何线程只要注册窗口类都会有一个消息队列用于接收用户输入的消息和系统消息。为了拦截消息，Windows提出了钩子的概念。钩子（Hook）是Windows消息处理机制中的一个监视点，钩子提供一个回调函数。当在某个程序中安装钩子后，它将监视该程序的消息，在指定消息还没到达窗口之前钩子程序先捕获这个消息。这样就有机会对此消息进行过滤，或者对Windows消息实现监控。 消息钩子分为局部钩子和全局钩子。局部钩子是指仅拦截某一个进程的消息，全局钩子将拦截系统中所有进程的消息。 该技术需要我们写一个简单的加载该DLL的程序，使其调用DLL的钩子函数，该函数会下一个全局消息钩子，强迫所有发生该消息的进程加载该DLL，这样就实现了DLL注入。 3.手工修改导入表 该方法需要我们熟悉PE结构，找到导入表位置在其后面添加一个新节，写入待注入的DLL，并将该DLL的导出函数的一些信息写到正确的位置，若导出函数过多将花费很多时间在手工修改上，并且可能出现空间不足写入的情况。 4.远程线程注入DLL 通过利用2000/XP等系统所有进程加载Kernel32.dll的模块基址一致的特点，先使用OpenProcess函数打开远程进程的句柄，再用VirtualAllocEx和WriteProcessMemory将待注入DLL路径写入目标进程，找到LoadLibraryW的地址，最后用CreateRemoteThread使目标进程调用LoadLibraryW加载DLL，参数为写入的DLL路径。 5.APC注入 APC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的。利用QueueUserAPC()可以向APC队列投入Loadlibrary函数指针完成注入，其实这种方法配合CreateProcess使用注入最为简单，先挂起打开线程，再QueueUserAPC()，再恢复线程，完成注入。 6.DLL劫持 自己实现应用程序的某个DLL，完成其导出函数，并将其放于应用程序目录下，当程序打开并加载DLL时会优先加载该目录下的DLL，原来的DLL若在该目录下降其移走即可。 7.输入法注入 利用输入法在工作时需要向进程中加载Ime文件（其实就是个Dll）,我们构造自己的Ime文件，在Ime文件注入对方进程的时候加载我们自己的DLL完成注入 8.内核驱动注入 代码注入方法 对于病毒来讲，虽然远程注入DLL相对隐蔽，但是因为在被注入进程中多了个DLL模块，所以也没有做到完全隐蔽，而且也很容易将病毒清除。所以对于那些更高级的病毒则使用了更加隐蔽，更加难以清除的方法：远程代码注入。这是指，在远程进程中开辟足够大的内存空间，然后将要执行的代码直接写过去，最后使用远程线程的方法运行注入代码。这样做可以使其他进程执行病毒代码，而又不会在对方进程中产生新的模块，从而使病毒能够更隐蔽地运行。 1.手工修改执行起始地址 使用二进制编辑工具打开目标程序，找到合适的地方写入二进制代码，将程序执行起始地址(AddressOfEntryPoint)改为注入代码处，在执行完后跳到源地址。 2.挂起线程注入 OpenThread–&gt;SuspendThread–&gt;申请内存–&gt;写入代码–&gt;GetThreadContext–&gt;获取EIP–&gt;修改EIP–&gt;SetThreadContext–&gt;ResumeThread。 3.挂起进程注入 CreateProcess注入方法之一，CREATE_SUSPENDED以挂起的方式打开进程，后面方法与挂起线程注入相似。 4.调试器注入 CreateProcess注入方法之二，DEBUG_ONLY_THIS_PROCESS以调试的方法打开进程，利用CREATE_PROCESS_DEBUG_EVENT，向目标程序中写入我们的ShellCode完成相应功能，并且我们的ShellCode中写入以CC断点，代码执行指令时触发EXCEPTION_DEBUG_EVENT事件，在EXCEPTION_DEBUG_EVENT的处理函数中回到原来的执行流程。 参考 Ring3注入总结及编程实现【有码】","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://stanfordzhang.com/tags/Windows/"},{"name":"Inject DLL","slug":"Inject-DLL","permalink":"http://stanfordzhang.com/tags/Inject-DLL/"},{"name":"Inject Code","slug":"Inject-Code","permalink":"http://stanfordzhang.com/tags/Inject-Code/"}]},{"title":"191226-Session Isolation in Windows","slug":"191226-Session-Isolation-in-Windows","date":"2019-12-26T02:29:17.000Z","updated":"2019-12-26T07:37:49.820Z","comments":true,"path":"post/28e99b3c.html","link":"","permalink":"http://stanfordzhang.com/post/28e99b3c.html","excerpt":"概述深入理解Windows会话隔离机制。2006年，微软发布了Vista系统和引入了一些新安全特性。其中一个重要的变化就是Session 0隔离机制，这是对Vista及后续版本服务加强的一部分。","text":"概述深入理解Windows会话隔离机制。2006年，微软发布了Vista系统和引入了一些新安全特性。其中一个重要的变化就是Session 0隔离机制，这是对Vista及后续版本服务加强的一部分。 Windows ServiceWindows服务的特点： 计算机启动时自动启动 可以被停止或重启 无论有没有用户登录，都会在后台运行 可以在用户账号环境里操作 Session 0 隔离第一个用户登录到Windows都会被放到一个单独的Session中。系统启动的时候，Session 0被创建，并且其他的Session在需要的时候被创建。服务总是运行在Session 0。然后，在Windows XP和早期Windows版本中，Session 0可以运行用户程序。如果Windows XP中启用了Fast User Switching，Session 0被分配给第一个登录的用户，用户运行的程序都在Session 0。第2个用户被分配到Session 1，其他以此类推。 当在同一个Session里运行服务和应用时，会出现几个安全问题。例如，如果病毒没有以服务的方式安装且运行在高权限账户，可以在用户系统造成大的破坏。 从Vista开始，微软在Session 0引入了两个重要的变化来减缓这些问题： Session 0被从服务和非交互用户程序里单独拿出来。登录到系统的用户和它们的应用必须运行在Session 1或更高的Session上。 Session 0不支持用户界面。运行在Session 0的进程不能访问图形硬件，因此用户界面不能直接显示在显示器上。 Session 0隔离带来的潜在问题在这些变更下，Session如何与服务及基于服务的驱动交互，现在来Review下那些可能影响应用和驱动的潜在影响。 如果驱动是被服务加载的或进程运行在Session 0, 一些驱动将被这些变更影响，涉及到的驱动包括： Spooler服务加载的打印机驱动 使用User-Mode Driver Framework (UMDF)授权的驱动，因为Session 0里的进程管理这些驱动 假如用户运行在Session 0，被这些新特性影响的应用程序类型包括所有服务和服务管理的驱动；这些不能在Vista及以后版本中运行。受影响的应用程序分类所下： Session 0里的服务创建了UI。用户是看不到用户界面的，比如对话框，在Session 0里创建，但不能在Session 0里运行，因此不能提供服务需要的输入。服务看着像功能失效了，但事实上它是在等用户的响应。但是服务可以使用WTSSendMessage函数来解决这个问题。使用这个函数，服务可以用户桌面创建一个简单的Message Box，用来给用户通知或提供简单的响应。 想要和应用程序通过Windows Message通信（SendMessage &amp; PostMessage）的服务。当应用程序正在不同的Session或Message Queue里运行时，服务的消息永远不会到达。这也会使用应用程序通过Windows消息和服务通信。微软推荐使用诸如RPC或Named Pipe等Client/Server机制在服务和应用程序之间通讯。 参考 Understanding Session in Windows Session Isolation 穿透Session 0 隔离（一） Windows 服务的Session 0 隔离机制","categories":[],"tags":[{"name":"Session 0","slug":"Session-0","permalink":"http://stanfordzhang.com/tags/Session-0/"},{"name":"Session Isolation","slug":"Session-Isolation","permalink":"http://stanfordzhang.com/tags/Session-Isolation/"},{"name":"Session隔离","slug":"Session隔离","permalink":"http://stanfordzhang.com/tags/Session隔离/"}]},{"title":"191118-Ubuntu 16.04安装checksec工具","slug":"191118-Ubuntu-16-04安装checksec工具","date":"2019-11-18T07:42:25.000Z","updated":"2019-11-18T07:54:49.106Z","comments":true,"path":"post/49480975.html","link":"","permalink":"http://stanfordzhang.com/post/49480975.html","excerpt":"概述Ubuntu 16.04 32-Bit安装checksec。","text":"概述Ubuntu 16.04 32-Bit安装checksec。 安装步骤123git clone https://github.com/slimm609/checksec.sh.gitcd checksec.shsudo ln –sf checksec /usr/bin/checksec 参考 Linux PWN从入门到熟练 checksec未完待续~","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://stanfordzhang.com/tags/pwn/"},{"name":"checksec","slug":"checksec","permalink":"http://stanfordzhang.com/tags/checksec/"}]},{"title":"191012-算法-C-将句子里的单词位置反转","slug":"191012-算法-C-将句子里的单词位置反转","date":"2019-10-12T08:58:38.000Z","updated":"2019-10-12T09:01:15.265Z","comments":true,"path":"post/7da00770.html","link":"","permalink":"http://stanfordzhang.com/post/7da00770.html","excerpt":"概述将一个只包含字母和空格的英文句子中的单词位置反转。比如：A cat has nine liveslives nine has cat A","text":"概述将一个只包含字母和空格的英文句子中的单词位置反转。比如：A cat has nine liveslives nine has cat A C语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void reverse_string(char *s, size_t begin, size_t end) &#123; char tmp = '\\0'; while (end &gt; begin) &#123; tmp = s[begin]; s[begin] = s[end]; s[end] = tmp; ++ begin; -- end; &#125;&#125;void reverse_sentence(char *s) &#123; size_t begin = 0; size_t end = 0; size_t i = 0; size_t len = strlen(s); reverse_string(s, 0, len - 1); // 先全部翻转 while(i &lt; strlen(s)) &#123; // 而后分个翻转 while(s[i] == ' ' &amp;&amp; i &lt; strlen(s)) &#123; ++ i; &#125; begin = i; while(s[i] != ' ' &amp;&amp; i &lt; strlen(s)) &#123; ++ i; &#125; end = i - 1; reverse_string(s, begin, end); &#125;&#125;int main(int argc, const char * argv[]) &#123; char s[64] = \"A cat has nine lives\"; printf(\"%s\\n\", s); reverse_sentence(s); printf(\"%s\\n\", s); return 0;&#125;","categories":[],"tags":[]},{"title":"191003-C语言异常处理机制","slug":"191003-C语言异常处理机制","date":"2019-10-03T08:35:22.000Z","updated":"2019-10-03T09:38:02.995Z","comments":true,"path":"post/cd623382.html","link":"","permalink":"http://stanfordzhang.com/post/cd623382.html","excerpt":"概述异常一般指的是程序运行期（Runtime）发生的非正常情况。异常一般是不可预测的，如：内存不足、打开文件失败、索引越界等，UNIX使用信号给出异常，并当发生异常时转跳到信号处理过程进行异常处理。异常都被认为是一种很优雅的处理错误的机制，异常处理的核心思想是把功能模块代码与系统中可能出现错误的处理代码分离开来，以此来达到使我们的代码组织起来更美观、逻辑上更清晰，并且同时从根本上来提高我们软件系统长时间稳定运行的可靠性。","text":"概述异常一般指的是程序运行期（Runtime）发生的非正常情况。异常一般是不可预测的，如：内存不足、打开文件失败、索引越界等，UNIX使用信号给出异常，并当发生异常时转跳到信号处理过程进行异常处理。异常都被认为是一种很优雅的处理错误的机制，异常处理的核心思想是把功能模块代码与系统中可能出现错误的处理代码分离开来，以此来达到使我们的代码组织起来更美观、逻辑上更清晰，并且同时从根本上来提高我们软件系统长时间稳定运行的可靠性。 C语言异常处理基础一个结构体：jmp_buf。这个结构定义在setjmp.h头文件中，在不同平台定义有所不同，请自行查阅。该结构主要用于保存当前寄存器的值。 两个函数： 12void _cdecl longjmp(jmp_buf jmpb, int retval);int _cdecl setjmp(jmp_buf jmpb); 调用简介： 首先调用setjmp()初始化jmp_buf结构体，将当前CPU中的大部分影响到程序执行的寄存器的值存入jmp_buf，为longjmp()函数提供跳转。setjmp()函数初始化时，返回0。longjmp()函数被调用后，跳转到setjmp()函数执行，返回值由longjmp()的第二个参数给出。在使用setjmp()初始化jmp_buf后，可以在其后程序的任意地方使用longjmp()函数跳转到setjmp()的位置，longjmp()的第一个参数便是setjmp()初始化的jmp_buf，若想跳转回刚才设置的setjmp()处，则longjmp()函数的第一个参数是setjmp()所初始化的jmp_buf这个异常，longjmp()函数的第二个参数是传给setjmp()的返回值。 示例123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include&lt;setjmp.h&gt;jmp_buf expt;int foo(void) &#123; printf(\"enter foo()\\n\"); // Step 6 longjmp(expt,1); // throw exception // Step 7 printf(\"leave foo()\\n\");&#125;int main(int argc, const char * argv[]) &#123; printf(\"enter main()\\n\"); // Step 1 int state = setjmp(expt); // Step 2; Step 8 if(state == 0) &#123; // return 0 after initializing // Step 3 printf(\"call foo()\\n\"); // Step 4 foo(); // Step 5 printf(\"return from foo()\\n\"); &#125; else &#123; // Step 9 switch(state)&#123; // Step 10 case 1: // Step 11 printf(\"catched!\\n\"); // Step 12 &#125; &#125; printf(\"leave main()\\n\"); // Step 13 return 0;&#125; 输出： 12345enter main()call foo()enter foo()catched!leave main() 根据注释中的Step X顺序和调用输出顺序可以很明显看出调用过程。 参考 c语言异常处理机制 c语言实现异常处理","categories":[],"tags":[{"name":"C Language","slug":"C-Language","permalink":"http://stanfordzhang.com/tags/C-Language/"},{"name":"Exception","slug":"Exception","permalink":"http://stanfordzhang.com/tags/Exception/"}]},{"title":"191002-iOS/macOS中Objective-C的Block实现原理","slug":"191002-iOS-macOS中Objective-C的Block实现原理","date":"2019-10-02T12:59:40.000Z","updated":"2019-10-02T13:31:45.085Z","comments":true,"path":"post/ce647558.html","link":"","permalink":"http://stanfordzhang.com/post/ce647558.html","excerpt":"概述block 实际上就是 Objective-C 语言的闭包实现。block 配合上 dispatch_queue，可以方便地实现简单的多线程编程和异步编程block 是一个对象，可以放到NSArray等容器里。","text":"概述block 实际上就是 Objective-C 语言的闭包实现。block 配合上 dispatch_queue，可以方便地实现简单的多线程编程和异步编程block 是一个对象，可以放到NSArray等容器里。 Apple开源代码源代码地址：https://opensource.apple.com/source/libclosure/libclosure-67/ 相关原理请参考《Pro Multithreading and Memory Management for iOS and OS X with ARC》这本书的第五章。此书中有详细解释。原书下载地址 参考 iOS 探索Objective-C中Block的实现原理 iOS Block底层实现原理详解 谈Objective-C block的实现 block没那么难（一）：block的实现 block没那么难（二）：block和变量的内存管理 block没那么难（三）：block和对象的内存管理","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://stanfordzhang.com/tags/Objective-C/"},{"name":"Cocoa","slug":"Cocoa","permalink":"http://stanfordzhang.com/tags/Cocoa/"},{"name":"iOS","slug":"iOS","permalink":"http://stanfordzhang.com/tags/iOS/"},{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"},{"name":"Block","slug":"Block","permalink":"http://stanfordzhang.com/tags/Block/"},{"name":"__block","slug":"block","permalink":"http://stanfordzhang.com/tags/block/"}]},{"title":"191001-ObjC __bridge __bridge_retained __bridge_transfer详解","slug":"191001-ObjC-bridge-bridge-retained-bridge-transfer详解","date":"2019-10-01T12:26:54.000Z","updated":"2019-10-02T13:05:55.836Z","comments":true,"path":"post/596df1c0.html","link":"","permalink":"http://stanfordzhang.com/post/596df1c0.html","excerpt":"概述Foundation对象就是使用Objective-C创建出来的对象（一般以NS为前缀）。Core Foundation对象主要是使用C语言创建的对象（一般以CF为前缀）。两个框架创建的对象都使用引用计数管理内存。在MRC环境下，Core Foundation框架中的retain/release分别是CFRetain/CFRelease。Core Foundation与Foundation框架创建出来的对象区别很小，可以在不同的框架中使用，Foundation框架的API生成并持有的对象可以用Core Foundation框架的API释放，反过来也可以。 因为Core Foundation对象与Foundation对象没有区别，转换不需要额外的CPU资源，因此也被称为：Toll Free Bridge。","text":"概述Foundation对象就是使用Objective-C创建出来的对象（一般以NS为前缀）。Core Foundation对象主要是使用C语言创建的对象（一般以CF为前缀）。两个框架创建的对象都使用引用计数管理内存。在MRC环境下，Core Foundation框架中的retain/release分别是CFRetain/CFRelease。Core Foundation与Foundation框架创建出来的对象区别很小，可以在不同的框架中使用，Foundation框架的API生成并持有的对象可以用Core Foundation框架的API释放，反过来也可以。 因为Core Foundation对象与Foundation对象没有区别，转换不需要额外的CPU资源，因此也被称为：Toll Free Bridge。 __bridgeCF和ObjC对象转化时只涉及对象类型不涉及对象所有权的转化 12id obj = [[NSObject alloc]init];void *p = (__bridge void *)(obj); 编译器会提示插入(bridge void *)强制转换，然而bridge并不是安全的，管理时不注意对象的所有者，就会因为悬垂指针而导致程序崩溃。例如下面这段代码： 12345678void *p = 0;&#123; id obj = [[NSObject alloc]init]; p = (__bridge void *)(obj); NSLog(@\"1 == %ld\", CFGetRetainCount((CFTypeRef)p));&#125;NSLog(@\"2 == %ld\", CFGetRetainCount((CFTypeRef)p));NSLog(@\"class = %@\",[(__bridge id)p class]); 因为__bridge只是简单的进行了指针转换，并没有移交持有权，作用域外obj已经释放掉了，p就相当于指向了一块已经释放的内存，因此作用域外访问p就会崩溃。 __bridge_transfer常用在CF对象转化成ObjC对象时，将CF对象的所有权交给OC对象，此时ARC就能自动管理该内存，作用同CFBridgingRelease() 1234567CFMutableArrayRef cfObject = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);printf(\"retain count = %ld\\n\",CFGetRetainCount(cfObject));id obj = CFBridgingRelease(cfObject);// 或// id obj = (__bridge_transfer id)cfObject;printf(\"retain count after the cast = %ld\\n\",CFGetRetainCount(cfObject)); 输出： 12retain count = 1retain count after the cast = 1 cfObject转换成obj的时候，相当于cfObject的持有权转交给了ARC，你不用负责obj的释放了。 __bridge_retained与bridge_transfer相反，常用在将ObjC对象转化成CF对象，且OC对象的所有权也交给CF对象来管理，即OC对象转化成CF对象时，涉及到对象类型和对象所有权的转化，作用同CFBridgingRetain() 修改下__bridge的例子： 12345678910void *p = 0;&#123; id obj = [[NSObject alloc]init]; p = (__bridge_retained void *)(obj); NSLog(@\"1 == %ld\", CFGetRetainCount((CFTypeRef)p));&#125;NSLog(@\"2 == %ld\", CFGetRetainCount((CFTypeRef)p));NSLog(@\"class = %@\",[(__bridge id)p class]);CFRelease(p);p = NULL; 我们将上面的bridge修改为bridge_retained就能解决问题。相当于在作用域内对p执行了retain操作。obj的引用计数为2，作用域结束时obj释放，引用计数变为1，p仍然持有对象，使用完以后记得要调用CFRelease(p)释放p，ARC是不会负责。 参考 理解bridge，bridge_transfer和__bridge_retained iOS开发之bridge，bridge_transfer和__bridge_retained","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://stanfordzhang.com/tags/Objective-C/"},{"name":"Cocoa","slug":"Cocoa","permalink":"http://stanfordzhang.com/tags/Cocoa/"},{"name":"__bridge","slug":"bridge","permalink":"http://stanfordzhang.com/tags/bridge/"},{"name":"__bridge_retained","slug":"bridge-retained","permalink":"http://stanfordzhang.com/tags/bridge-retained/"},{"name":"__bridge_transfer","slug":"bridge-transfer","permalink":"http://stanfordzhang.com/tags/bridge-transfer/"}]},{"title":"191001-ObjC __unsafe_unretained & __weak","slug":"191001-ObjC-unsafe-unretained-weak","date":"2019-10-01T12:16:04.000Z","updated":"2019-10-01T12:26:33.630Z","comments":true,"path":"post/41eaffdf.html","link":"","permalink":"http://stanfordzhang.com/post/41eaffdf.html","excerpt":"概述日常开发中unsafe_unretained用的不多，只是在一些开源的源码中看到。 unsafe_unretained和__weak一样，表示的是对象的一种弱引用关系，唯一的区别是： __weak修饰的对象被释放后，指向对象的指针会置空，也就是指向nil，不会产生野指针； 而__unsafe_unretained修饰的对象被释放后，指针不会置空，而是变成一个野指针，那么此时如果访问这个对象的话，程序就会Crash，抛出BAD_ACCESS的异常。","text":"概述日常开发中unsafe_unretained用的不多，只是在一些开源的源码中看到。 unsafe_unretained和__weak一样，表示的是对象的一种弱引用关系，唯一的区别是： __weak修饰的对象被释放后，指向对象的指针会置空，也就是指向nil，不会产生野指针； 而__unsafe_unretained修饰的对象被释放后，指针不会置空，而是变成一个野指针，那么此时如果访问这个对象的话，程序就会Crash，抛出BAD_ACCESS的异常。 为什么有weak还需要用unsafe_unretainedweak对性能会有一定的消耗，使用weak，需要检查对象是否被释放，在追踪是否被释放的时候当然需要追踪一些信息，那么此时unsafe_unretained比weak快，而且一个对象有大量的__weak引用对象的时候，当对象被废弃，那么此时就要遍历weak表，把表里所有的指针置空，消耗cpu资源。 什么时候使用__unsafe_unretained当你明确对象的生命周期的时候，可以使用unsafe_unretained替代weak,可以稍微提高一些性能，虽然这点性能微乎其微。 举个例子，当A拥有B对象，A消亡B也消亡，这样当B存在，A也一定会存在的时候，此时B要调用A的接口，就可以通过__unsafe_unretained保持对A的引用关系。 比如 MyViewController拥有MyView, MyView需要调用MyViewController的接口。MyView中就可以通过__unsafe_unretained保持对MyViewController的引用。 参考 __unsafe_unretained 的理解和使用","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://stanfordzhang.com/tags/Objective-C/"},{"name":"Cocoa","slug":"Cocoa","permalink":"http://stanfordzhang.com/tags/Cocoa/"},{"name":"__unsafe_unretained","slug":"unsafe-unretained","permalink":"http://stanfordzhang.com/tags/unsafe-unretained/"},{"name":"__weak","slug":"weak","permalink":"http://stanfordzhang.com/tags/weak/"},{"name":"iOS","slug":"iOS","permalink":"http://stanfordzhang.com/tags/iOS/"},{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"191001-Windows进程创建过程","slug":"191001-Windows进程创建过程","date":"2019-10-01T02:42:37.000Z","updated":"2019-10-01T12:15:49.752Z","comments":true,"path":"post/3986987d.html","link":"","permalink":"http://stanfordzhang.com/post/3986987d.html","excerpt":"概述进程（Process）是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。而进程则不同，它是程序在某个数据集上的执行，是一个动态实体。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消，反映了一个程序在一定的数据集上运行的全部动态过程。 线程（Thread）是进程的一个实体，是CPU调度和分派的基本单位。线程不能够独立执行，必须依存在进程中，由进程提供多个线程执行控制。从内核角度讲线程是活动体对象，而进程只是一组静态的对象集，进程必须至少拥有一个活动线程才能维持运转。","text":"概述进程（Process）是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。而进程则不同，它是程序在某个数据集上的执行，是一个动态实体。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消，反映了一个程序在一定的数据集上运行的全部动态过程。 线程（Thread）是进程的一个实体，是CPU调度和分派的基本单位。线程不能够独立执行，必须依存在进程中，由进程提供多个线程执行控制。从内核角度讲线程是活动体对象，而进程只是一组静态的对象集，进程必须至少拥有一个活动线程才能维持运转。 创建过程当调用创建进程的函数比如CreateProcess或者用户执行某一个程序（其实Windows下用户执行一般普通程序是由explorer.exe调用CreateProcess来完成），操作系统把这个过程分成以下步骤来完成： 打开将要在该进程中执行的映像文件。 创建Windows执行体进程对象。 创建初始线程（栈、堆执行环境初始化及执行线程体对象）。 通知Windows子系统新进程创建了（子系统是操作系统的一部分它是一个协助操作系统内核管理用户态/客户方的一个子系统具体的进程为Csrss.exe）。 开始执行初始线程（如果创建时候指定了线程的CREATE_SUSPENDED状态则线程暂时挂起不执行）。 在新进程和线程环境中完成地址空间的初始化（比如加载必须的DLL和库），然后开始到进程入口执行。 到这里操作系统完成一个新进程的创建过程。 详细解释 打开将要在该进程中执行的映像文件。首先操作系统找到执行的Windows映像然后创建一个内存区对象，以便后面将它映射到新的进程地址空间中。 创建Windows执行体进程对象。接下来操作系统调用内部的系统函数NtCreateProcess来创建一个Windwos执行体进程对象。具体步骤是： (1) 建立EPROCESS 分配并初始化EPROCESS结构块 从父进程处继承得到进程的亲和性掩码 分配进程的最大最小工作集（由两个参数决定PsMinimumWorkingSet和PsMaximumWorkingSet） 将新进程的配额块设置为父进程配额块地址，并递增父进程配额块的引用计数 继承Windows的设备名字空间 将父进程进程ID保存在新进程对象的InheritedFormUniqueProcessId中 创建该进程的主访问令牌 初始化进程句柄表 将新进程的退出状态设置为STATUS_PENDING (2) 创建初始的进程地址空间 在适当的页表中创建页表项，以映射初始页面 从MmresidentAvailablePage算出进程工作集大小 系统空间的非换页部分和系统缓存的页表被映射到进程 (3) 初始化内核进程块KPROCESS (4) 结束进程地址空间的创建过程 (5) 建立PEB (6) 完成执行体进程对象的创建过程 创建初始线程（栈、堆执行环境初始化及执行线程体对象）。这时候Windows执行体进程对象已经完全建立完成，但它还没有线程所以无法执行，接下来系统调用NtCreateThread来创建一个挂起的新线程它就是进程的主线程体。 通知Windows子系统新进程创建了（子系统是操作系统的一部分它是一个协助操作系统内核管理用户态/客户方的一个子系统具体的进程为Csrss.exe）。接下来操作系统通过客户态(Kernel32.dll)给Windows子系统(Csrss)发送一个新进程线程创建的数据消息，让子系统建立自己的进程线程管理块。当Csrss接收到该消息时候执行下面的处理：复制一份该进程和线程句柄 设置进程优先级分配Csrss进程块 把新进程的异常处理端口绑定到Csrss中，这样当该进程发生异常时，Csrss将会接收到异常消息分配和初始化Csrss线程块 把线程插入到进程的线程列表中把进程插入到Csrss的线程列表中 显示进程启动光标 开始执行初始线程(如果创建时候指定了线程的CREATE_SUSPENDED状态则线程暂时挂起不执行)。到这里进程环境已经建立完毕进程中开始创建的主线程到这里获得执行权开始执行线程 在新进程和线程环境中完成地址空间的初始化（比如加载必须的DLL和库），然后开始到进程入口执行。到这步实质是调用ldrInitializeThunk来初始化加载器，堆管理器NLS表TLS数组以及临界区结构，并且加载任何必须要的DLL并且用DLL_PROCESS_ATTACH功能代码来调用各DLL入口点，最后当加载器初始化例程返回到用户模式APC分发器时进程映像开始在用户模式下执行，然后它调用线程启动函数开始执行。 到这里操作系统完成了所有的创建工作，我们写的程序就这样被操作系统调用运行起来了。 参考 Windows操作系统下创建进程的过程 windows进程/线程创建过程 windows 进程运行过程 关于Windows创建进程的过程 Windows进程创建的流程分析 进程的创建过程","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://stanfordzhang.com/tags/Windows/"},{"name":"进程创建","slug":"进程创建","permalink":"http://stanfordzhang.com/tags/进程创建/"},{"name":"内核","slug":"内核","permalink":"http://stanfordzhang.com/tags/内核/"}]},{"title":"Introduction to Linux Zombie Process","slug":"Introduction-to-Linux-Zombie-Process","date":"2019-09-30T09:37:34.000Z","updated":"2019-09-30T10:01:38.542Z","comments":true,"path":"post/22042d32.html","link":"","permalink":"http://stanfordzhang.com/post/22042d32.html","excerpt":"概述Linux允许进程查询内核以获得其父进程的PID，或者其任何子进程的执行状态。例如，进程可以创建一个子进程来执行特定的任务，然后调用诸如wait()这样的一些库函数检查子进程是否终止。如果子进程已经终止，那么，它的终止代号将告诉父进程这个任务是否已成功地完成。为了遵循这些设计原则，不允许Linux内核在进程终止后就丢弃包含在进程描述符字段中的数据。只有父进程发出了与被终止的进程相关的wait()类系统调用之后，才允许这样做。这就是引入僵死状态的原因：尽管从技术上来说进程已死，但必须保存它的描述符，直到父进程得到通知。如果一个进程已经终止，但是它的父进程尚未调用wait()或waitpid()对它进行清理，这时的进程状态称为僵死状态，处于僵死状态的进程称为僵尸进程(Zombie Process)。任何进程在刚终止时都是僵尸进程，正常情况下，僵尸进程都立刻被父进程清理了。","text":"概述Linux允许进程查询内核以获得其父进程的PID，或者其任何子进程的执行状态。例如，进程可以创建一个子进程来执行特定的任务，然后调用诸如wait()这样的一些库函数检查子进程是否终止。如果子进程已经终止，那么，它的终止代号将告诉父进程这个任务是否已成功地完成。为了遵循这些设计原则，不允许Linux内核在进程终止后就丢弃包含在进程描述符字段中的数据。只有父进程发出了与被终止的进程相关的wait()类系统调用之后，才允许这样做。这就是引入僵死状态的原因：尽管从技术上来说进程已死，但必须保存它的描述符，直到父进程得到通知。如果一个进程已经终止，但是它的父进程尚未调用wait()或waitpid()对它进行清理，这时的进程状态称为僵死状态，处于僵死状态的进程称为僵尸进程(Zombie Process)。任何进程在刚终止时都是僵尸进程，正常情况下，僵尸进程都立刻被父进程清理了。 僵尸进程是如何产生的在UNIX系统中，一个进程结束后，但是它的父进程没有等待（调用wait/waitpid）他，那么它将变成一个僵尸进程。通过ps命令查看其带有defunct的标志。僵尸进程是一个早已死亡的进程，但在进程表（processs table）中仍占了一个位置（slot）。但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程，看看有没有哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由Init进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而Init进程会自动wait其子进程，因此被Init接管的所有进程都不会变成僵尸进程。 为了观察到僵尸进程，写一个不正常的程序，父进程fork出子进程，子进程终止，而父进程既不终止也不调用 wait 清理子进程: 12345678910111213141516171819202122232425262728// demo1.c#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int i = 100; pid_t pid=fork(); if(pid &lt; 0) &#123; perror(\"fork failed.\"); exit(1); &#125; if(pid &gt; 0) &#123; printf(\"This is the parent process. My PID is %d.\\n\", getpid()); for(; i &gt; 0; i--) &#123; sleep(1); &#125; &#125; else if(pid == 0) &#123; printf(\"This is the child process. My PID is: %d. My PPID is: %d.\\n\", getpid(), getppid()); &#125; return 0;&#125; 编译、运行、查看进程状态： 12345678910&gt; gcc demo1.c -o demo1&gt; ./demo1This is the parent process. My PID is 1718.This is the child process. My PID is: 1719. My PPID is: 1718.&gt; ps aux | grep demo1pc 2217 0.0 0.0 4504 716 pts/1 S+ 02:44 0:00 ./demo1pc 2218 0.0 0.0 0 0 pts/1 Z+ 02:44 0:00 [demo1] &lt;defunct&gt;pc 2220 0.0 0.0 23252 1148 pts/0 S+ 02:45 0:00 grep --color=auto demo1 可以看到进程PID为2218的进程状态是Z+，说明该进程处于僵死状态。 如果此时中止父进程，再查看进程列表，发现进程都不见了。这是因为当父进程退出后，子进程会变成孤儿进程，此时它会被一个管理进程收养。在不同的系统中，这个管理进程不太一样，早期一般是init进程，Ubuntu上是upstart，还有近来的Systemd。但是它们都完成相同的任务，就是wiat()这些孤儿进程，并最终释放它们占用的系统进程表中的资源。这样，这些已经僵死的孤儿进程就彻底的被清除了。 僵尸进程的危害在进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息(包括进程号PID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等)。直到父进程通过wait/waitpid来取时才释放。 如果进程不调用wait/waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。 如何处理僵尸进程僵尸进程的产生是因为父进程没有wait()子进程。所以如果我们自己写程序的话一定要在父进程中通过wait()来避免僵尸进程的产生。 当系统中出现了僵尸进程时，我们是无法通过kill命令把它清除掉的。但是我们可以杀死它的父进程，让它变成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。 下面的demo2.c中，父进程通过wait()等待子进程结束： 12345678910111213141516171819202122232425262728293031323334353637// demo2.c#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; pid_t pid; pid = fork(); if (pid &lt; 0) &#123; perror(\"fork failed\"); exit(1); &#125; if (pid == 0) &#123; int i; for (i = 3; i &gt; 0; i--) &#123; printf(\"This is the child\\n\"); sleep(1); &#125; // exit with code 3 for test. exit(3); &#125; else &#123; int stat_val; wait(&amp;stat_val); if (WIFEXITED(stat_val)) &#123; printf(\"Child exited with code %d\\n\", WEXITSTATUS(stat_val)); &#125; &#125; return 0;&#125; demo2中父进程不仅等待子进程结束，还通过WEXITSTATUS宏取到了子进程的 exit code。 参考 Linux 僵尸进程产生原因及解决方法 Linux僵尸进程","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://stanfordzhang.com/tags/Linux/"},{"name":"Zombie Process","slug":"Zombie-Process","permalink":"http://stanfordzhang.com/tags/Zombie-Process/"}]},{"title":"Introduction to C++ Global and Local Static Object's Lifecycle","slug":"Introduction-to-C-Global-and-Local-Static-Object-s-Lifecycle","date":"2019-09-30T04:29:22.000Z","updated":"2019-09-30T07:38:14.586Z","comments":true,"path":"post/e159c7f6.html","link":"","permalink":"http://stanfordzhang.com/post/e159c7f6.html","excerpt":"概述在开发C++项目时，经常会使用到全局对象，虽然不太推荐使用，但用的妙却有不一样的效果，需要慎用。本文详细介绍下C++中全局变量的生命周期。","text":"概述在开发C++项目时，经常会使用到全局对象，虽然不太推荐使用，但用的妙却有不一样的效果，需要慎用。本文详细介绍下C++中全局变量的生命周期。 预备几个PE段的说明 data段:存放在编译阶段(而非运行时)就能确定的数据,可读可写就是通常所说的静态存储区,赋了初值的全局变量和静态变量存放在这个域,常量也存放在这个区域。 .rdata段：rdata是用来存放只读实始化变量的，当我们在源程序中的变量前面加了const后，编译器知道个字符串是永远不会改变的，或说是只读的，所以将其分配到.rdata段中。 .bss段:定义而没有赋初值的全局变量和静态变量,放在这个区域 .idata：（数据段），导入函数的代码段，存放外部函数地址。 一般C语言的编译后执行语句都编译成机器代码，保存在.text段。已初始化的全局变量和局部静态变量都保存在.data段未初始化的全局变量一般放在一个叫.“bss”的段里。 全局变量和静态变量在源文件中定义： 12345static int n; //定义静态全局变量 .dataint n; // 全局变量 .dataconst int n = 0; // .rdata 区别： 全局变量是不显式用static修饰的全局变量，但全局变量默认是动态的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern全局变量名的声明，就可以使用全局变量. 全局静态变量是显式用static修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用extern声明也不能使用。 文件作用域下声明的const的常量默认为static存储类型。 认识atexit函数atexit函数的声明为： 1int atexit( void ( __cdecl *func )( void ) ); 参数为函数指针，返回值为整型，0表示成功，其他表示失败。当程序运行结束时，他调用atexit函数注册的所有函数。如果多次调用atexit函数，那么系统将以LIFO(last-in-first-out)的方式调用所有的注册函数。 MSDN示例： 123456789101112131415161718192021222324252627282930举例如下（代码摘自MSDN）：#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void fn1( void ), fn2( void ), fn3( void ), fn4( void );void main( void )&#123; atexit( fn1 ); atexit( fn2 ); atexit( fn3 ); atexit( fn4 ); printf( \"This is executed first.\\n\" );&#125;void fn1()&#123; printf( \"next.\\n\" );&#125;void fn2()&#123; printf( \"executed \" );&#125;void fn3()&#123; printf( \"is \" );&#125;void fn4()&#123; printf( \"This \" );&#125; 编译、运行程序后，程序的输出为： 12&gt; This is executed first.&gt; This is executed next. 注册函数的顺序为：fn1、fn2、fn3、fn4，但是调用顺序为fn4、fn3、fn2、fn1。 局部静态变量示例代码： 12345678910111213141516171819class Dummy&#123;public: Dummy() &#123; printf(\"Dummy\\n\"); &#125; ~Dummy() &#123; printf(\"~Dummy\\n\"); &#125;&#125;;static Dummy dummy1; // 全局静态变量int main(int argc, char* argv[])&#123; static Dummy dummy2; // 局部静态变量 printf(\"Hello world!\\n\"); return 0;&#125; 再看局部静态变量static Dummy dummy2;这一段的反汇编： 1234567891011121314static Dummy dummy2;00DE13FD mov eax,dword ptr [$S1 (0DEA140h)]00DE1402 and eax,100DE1405 jne main+79h (0DE1439h)00DE1407 mov eax,dword ptr [$S1 (0DEA140h)]00DE140C or eax,100DE140F mov dword ptr [$S1 (0DEA140h)],eax00DE1414 mov dword ptr [ebp-4],000DE141B mov ecx,offset dummy2 (0DEA144h)00DE1420 call Dummy::Dummy (0DE10C8h) // 调用构造函数00DE1425 push offset `main&apos;::`2&apos;::`dynamic atexit destructor for &apos;dummy2&apos;&apos; (0DE66E0h)00DE142A call @ILT+100(_atexit) (0DE1069h) // 将dummy2的析构函数放入atexit队列00DE142F add esp,400DE1432 mov dword ptr [ebp-4],0FFFFFFFFh 从反汇编可知，局部静态对象是在执行到对象定义的地方执行构造函数，同时将析构函数注册到main函数退出(atexit)后执行清理的队列里。参考Introduction to Visual C++ 2008 C/C++ Runtime(CRT)中的doexit部分。 全局变量或全局静态变量代码同上，对象dummy1。 构造函数调用栈： 123456789demo1.exe!Dummy::Dummy() Line 10demo1.exe!`dynamic initializer for &apos;dummy1&apos;&apos;() Line 17 + 0x28 bytesmsvcr90d.dll!_initterm(void (void)* * pfbegin=0x00de8208, void (void)* * pfend=0x00de830c) Line 903demo1.exe!__tmainCRTStartup() Line 501 + 0xf bytesdemo1.exe!mainCRTStartup() Line 403kernel32.dll!752b6359()[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]ntdll.dll!77b17b74()ntdll.dll!77b17b44() 12345678910demo1.exe!Dummy::~Dummy() Line 13demo1.exe!`dynamic atexit destructor for &apos;dummy1&apos;&apos;() + 0x28 bytesmsvcr90d.dll!doexit(int code=0, int quick=0, int retcaller=0) Line 591msvcr90d.dll!exit(int code=0) Line 412 + 0xd bytesdemo1.exe!__tmainCRTStartup() Line 599demo1.exe!mainCRTStartup() Line 403kernel32.dll!752b6359()[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]ntdll.dll!77b17b74()ntdll.dll!77b17b44() 参考Introduction to Visual C++ 2008 C/C++ Runtime(CRT)中的初始化和doexit部分。全局变量在_initterm中构造，在doexit中析构。 引用 Introduction to Visual C++ 2008 C/C++ Runtime(CRT) 静态对象、全局对象与程序的运行机制 静态全局变量和全局变量的区别","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://stanfordzhang.com/tags/C/"},{"name":"Runtime","slug":"Runtime","permalink":"http://stanfordzhang.com/tags/Runtime/"},{"name":"Global Object","slug":"Global-Object","permalink":"http://stanfordzhang.com/tags/Global-Object/"},{"name":"全局变量的生命周期","slug":"全局变量的生命周期","permalink":"http://stanfordzhang.com/tags/全局变量的生命周期/"}]},{"title":"Introduction to Visual C++ 2008 C/C++ Runtime(CRT)","slug":"Introduction-to-Visual-C-2008-C-C-Runtime-CRT","date":"2019-09-30T01:33:53.000Z","updated":"2019-10-01T01:53:48.839Z","comments":true,"path":"post/e5f87e06.html","link":"","permalink":"http://stanfordzhang.com/post/e5f87e06.html","excerpt":"概述任何一个C/C++程序，它的背后都有一套庞大的代码来进行支撑其正常运行。这套代码至少包括入口函数，及其依赖的函数所构成的函数集合。当然，它还应该包括各种标准函数（如字符串，数学运算等）的实现。本文介绍VC++ 2008运行时库实现的原理，详细剖析main函数执行前后都做了什么。 以Proptertes-&gt;C/C++-&gt;Code Generation-&gt;Runtime Library-&gt;Multi-threaded Debug DLL(/MDd)为例。","text":"概述任何一个C/C++程序，它的背后都有一套庞大的代码来进行支撑其正常运行。这套代码至少包括入口函数，及其依赖的函数所构成的函数集合。当然，它还应该包括各种标准函数（如字符串，数学运算等）的实现。本文介绍VC++ 2008运行时库实现的原理，详细剖析main函数执行前后都做了什么。 以Proptertes-&gt;C/C++-&gt;Code Generation-&gt;Runtime Library-&gt;Multi-threaded Debug DLL(/MDd)为例。 前言Visual C++ 2008 CRT代码路径 C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\crt Source Code Copy https://github.com/stanfordzhang/vc9crt.git 每个进程都有一个默认堆，在进程初始化的时候会创建这个默认堆，可以通过GetProcessHeap()获取默认堆的句柄。在使用CRT时，也会有一个CRT堆，VC++项目Proptertes-&gt;C/C++-&gt;Code Generation-&gt;Runtime Library。如果选择Multi-threaded Debug DLL(/MDd)，则CRT堆初始化在DLL中；如果选择Multi-threaded Debug(/MTd)，则会在进入_tmain函数之前进行初始化。相关代码参考crt0.c和crt0dat.c两个文件。 找到真正的入口函数使用Visual Studio 2008创建Win32 Console Application，名字叫demo1。 默认情况下Code Generation-&gt;Runtime Library-&gt;Multi-threaded Debug DLL(/MDd)这个很重要，选择不同的Runtime Library，CRT初始化代码不一样。 测试代码如下： 12345int main(int arg, char* argv[])&#123; printf(\"Hello world!\\n\"); // 只增加了这行代码 return 0;&#125; 在printf那行下一个断点，可以看到调用栈如下所示： 1234demo1.exe!main(int argc=1,char** argv=0x014d49e8) Line 9demo1.exe!__tmainCRTStartup() Line 586 + 0x19 bytesdemo1.exe!mainCRTStartup() Line 403... 由调用栈可以看到由mainCRTStartup()调用__tmainCRTStartup()再调用我们的入口_tmain函数。 mainCRTStartup()代码在crt/src/crtexe.c(Line 374 - 403)中，如下： 123456789101112131415161718192021222324252627282930#ifdef _WINMAIN_#ifdef WPRFLAGint wWinMainCRTStartup(#else /* WPRFLAG */int WinMainCRTStartup(#endif /* WPRFLAG */#else /* _WINMAIN_ */#ifdef WPRFLAGint wmainCRTStartup(#else /* WPRFLAG */int mainCRTStartup(#endif /* WPRFLAG */#endif /* _WINMAIN_ */ void )&#123; /* * The /GS security cookie must be initialized before any exception * handling targetting the current image is registered. No function * using exception handling can be called in the current image until * after __security_init_cookie has been called. */ __security_init_cookie(); return __tmainCRTStartup();&#125; mainCRTStartup()函数中在对栈溢出进行安全性检查（security_init_cookie()）后就直接调用tmainCRTStartup()。 下面再看__tmainCRTStartup()的代码，在文件crt/src/crtexe.c(Line 405 - 624)中。说明见中文注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220__declspec(noinline)int__tmainCRTStartup( void )&#123;#ifdef _WINMAIN_ _TUCHAR *lpszCommandLine; STARTUPINFO StartupInfo; BOOL inDoubleQuote=FALSE; __try &#123; /* Note: MSDN specifically notes that GetStartupInfo returns no error, and throws unspecified SEH if it fails, so the very general exception handler below is appropriate */ GetStartupInfo( &amp;StartupInfo ); &#125; __except(EXCEPTION_EXECUTE_HANDLER) &#123; return 255; &#125;#endif /* _WINMAIN_ */ /* * Guard the initialization code and the call to user's main, or * WinMain, function in a __try/__except statement. */ __try &#123; /* * There is a possiblity that the module where this object is * linked into is a mixed module. In all the cases we gurantee that * native initialization will occur before managed initialization. * Also in anycase this code should never be called when some other * code is initializing native code, that's why we exit in that case. * * Do runtime startup initializers. * * Note: the only possible entry we'll be executing here is for * __lconv_init, pulled in from charmax.obj only if the EXE was * compiled with -J. All other .CRT$XI* initializers are only * run as part of the CRT itself, and so for the CRT DLL model * are not found in the EXE. For that reason, we call _initterm, * not _initterm_e, because __lconv_init will never return failure, * and _initterm_e is not exported from the CRT DLL. * * Note further that, when using the CRT DLL, executing the * .CRT$XI* initializers is only done for an EXE, not for a DLL * using the CRT DLL. That is to make sure the -J setting for * the EXE is not overriden by that of any DLL. */ void *lock_free=0; void *fiberid=((PNT_TIB)NtCurrentTeb())-&gt;StackBase; int nested=FALSE; while((lock_free=InterlockedCompareExchangePointer((volatile PVOID *)&amp;__native_startup_lock, fiberid, 0))!=0) &#123; if(lock_free==fiberid) &#123; nested=TRUE; break; &#125; /* some other thread is running native startup/shutdown during a cctor/domain unload. Should only happen if this DLL was built using the Everett-compat loader lock fix in vcclrit.h */ /* wait for the other thread to complete init before we return */ Sleep(1000); &#125; if (__native_startup_state == __initializing) &#123; _amsg_exit( _RT_CRT_INIT_CONFLICT); &#125; else if (__native_startup_state == __uninitialized) &#123; __native_startup_state = __initializing;#ifndef _SYSCRT if (_initterm_e( __xi_a, __xi_z ) != 0) &#123; return 255; &#125;#else /* _SYSCRT */ _initterm((_PVFV *)(void *)__xi_a, (_PVFV *)(void *)__xi_z);#endif /* _SYSCRT */ &#125; else &#123; has_cctor = 1; &#125; /* * do C++ constructors (initializers) specific to this EXE */ if (__native_startup_state == __initializing) &#123; _initterm( __xc_a, __xc_z ); __native_startup_state = __initialized; &#125; _ASSERTE(__native_startup_state == __initialized); if(!nested) &#123; /* For X86, the definition of InterlockedExchangePointer wrongly causes warning C4312 */#pragma warning(push)#pragma warning(disable:4312) InterlockedExchangePointer((volatile PVOID *)&amp;__native_startup_lock, 0);#pragma warning(pop) &#125; /* * If we have any dynamically initialized __declspec(thread) * variables, then invoke their initialization for the primary * thread used to start the process, by calling __dyn_tls_init * through a callback defined in tlsdyn.obj. */ if (__dyn_tls_init_callback != NULL &amp;&amp; _IsNonwritableInCurrentImage((PBYTE)&amp;__dyn_tls_init_callback)) &#123; __dyn_tls_init_callback(NULL, DLL_THREAD_ATTACH, NULL); &#125; /* Enable buffer count checking if linking against static lib */ _CrtSetCheckCount(TRUE);#ifdef _WINMAIN_ /* * Skip past program name (first token in command line). * Check for and handle quoted program name. */#ifdef WPRFLAG /* OS may not support \"W\" flavors */ if (_wcmdln == NULL) return 255; lpszCommandLine = (wchar_t *)_wcmdln;#else /* WPRFLAG */ lpszCommandLine = (unsigned char *)_acmdln;#endif /* WPRFLAG */ while (*lpszCommandLine &gt; SPACECHAR || (*lpszCommandLine&amp;&amp;inDoubleQuote)) &#123; /* * Flip the count from 1 to 0 or 0 to 1 if current character * is DOUBLEQUOTE */ if (*lpszCommandLine==DQUOTECHAR) inDoubleQuote=!inDoubleQuote;#ifdef _MBCS if (_ismbblead(*lpszCommandLine)) &#123; if (lpszCommandLine) &#123; lpszCommandLine++; &#125; &#125;#endif /* _MBCS */ ++lpszCommandLine; &#125; /* * Skip past any white space preceeding the second token. */ while (*lpszCommandLine &amp;&amp; (*lpszCommandLine &lt;= SPACECHAR)) &#123; lpszCommandLine++; &#125;#ifdef WPRFLAG mainret = wWinMain(#else /* WPRFLAG */ mainret = WinMain(#endif /* WPRFLAG */ (HINSTANCE)&amp;__ImageBase, NULL, lpszCommandLine, StartupInfo.dwFlags &amp; STARTF_USESHOWWINDOW ? StartupInfo.wShowWindow : SW_SHOWDEFAULT );#else /* _WINMAIN_ */#ifdef WPRFLAG __winitenv = envp; mainret = wmain(argc, argv, envp);#else /* WPRFLAG */ __initenv = envp; mainret = main(argc, argv, envp);// 这里是真正的main函数入口#endif /* WPRFLAG */#endif /* _WINMAIN_ */ /* * Note that if the exe is managed app, we don't really need to * call exit or _c_exit. .cctor should be able to take care of * this. */ if ( !managedapp ) exit(mainret); if (has_cctor == 0) _cexit(); &#125; __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) ) &#123; /* * Should never reach here */ mainret = GetExceptionCode(); /* * Note that if the exe is managed app, we don't really need to * call exit or _c_exit. .cctor should be able to take care of * this. */ if ( !managedapp ) _exit(mainret); if (has_cctor == 0) _cexit(); &#125; /* end of try - except */ return mainret;&#125; 我们在__tmainCRTStartup()中找到调用main函数的地方，由上面代码可以看到，在调用main函数之前需要做不少准备工作，接下来我们一一来分析下。 调用main函数之前的初始化和之后的清理工作注意：这里只分析Console程序相关的代码，关于类似WinMain的处理过程类似，不再赘述。 提取关键代码如下： 123Line 483: _initterm_e( __xi_a, __xi_z ) // 这里会调用pre_c_init进行初始化Line 501: _initterm( __xc_a, __xc_z ) // 这里会调用pre_cpp_init进行初始化和C++全局对象的构造函数Line 597: exit(mainret) // 这里实际调用doexit()，做一些C的清理工作，同时调用全局C++对象的析构函数 pre_cpp_init()中会获取命令参数及环境变量。 函数doexit()，在crt0dat.c(Line 508 - 645)中，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138static void __cdecl doexit ( int code, int quick, int retcaller )&#123;#ifdef _DEBUG static int fExit = 0;#endif /* _DEBUG */#ifdef CRTDLL if (!retcaller &amp;&amp; check_managed_app()) &#123; /* Only if the EXE is managed then we call CorExitProcess. Native cleanup is done in .cctor of the EXE If the Exe is Native then native clean up should be done before calling (Cor)ExitProcess. */ __crtCorExitProcess(code); &#125;#endif /* CRTDLL */ _lockexit(); /* assure only 1 thread in exit path */ __TRY if (_C_Exit_Done != TRUE) &#123; _C_Termination_Done = TRUE; /* save callable exit flag (for use by terminators) */ _exitflag = (char) retcaller; /* 0 = term, !0 = callable exit */ if (!quick) &#123; /* * do _onexit/atexit() terminators * (if there are any) * * These terminators MUST be executed in reverse order (LIFO)! * * NOTE: * This code assumes that __onexitbegin points * to the first valid onexit() entry and that * __onexitend points past the last valid entry. * If __onexitbegin == __onexitend, the table * is empty and there are no routines to call. */ _PVFV * onexitbegin = (_PVFV *)_decode_pointer(__onexitbegin); if (onexitbegin) &#123; _PVFV * onexitend = (_PVFV *)_decode_pointer(__onexitend); _PVFV function_to_call = NULL; /* save the start and end for later comparison */ _PVFV * onexitbegin_saved = onexitbegin; _PVFV * onexitend_saved = onexitend; while (1) &#123; _PVFV * onexitbegin_new = NULL; _PVFV * onexitend_new = NULL; /* find the last valid function pointer to call. */ while (--onexitend &gt;= onexitbegin &amp;&amp; *onexitend == _encoded_null()) &#123; /* keep going backwards. */ &#125; if (onexitend &lt; onexitbegin) &#123; /* there are no more valid entries in the list, we are done. */ break; &#125; /* cache the function to call. */ function_to_call = (_PVFV)_decode_pointer(*onexitend); /* mark the function pointer as visited. */ *onexitend = (_PVFV)_encoded_null(); /* call the function, which can eventually change __onexitbegin and __onexitend */ (*function_to_call)(); onexitbegin_new = (_PVFV *)_decode_pointer(__onexitbegin); onexitend_new = (_PVFV *)_decode_pointer(__onexitend); if ( ( onexitbegin_saved != onexitbegin_new ) || ( onexitend_saved != onexitend_new ) ) &#123; /* reset only if either start or end has changed */ onexitbegin = onexitbegin_saved = onexitbegin_new; onexitend = onexitend_saved = onexitend_new; &#125; &#125; &#125;#ifndef CRTDLL /* * do pre-terminators */ _initterm(__xp_a, __xp_z);#endif /* CRTDLL */ &#125;#ifndef CRTDLL /* * do terminators */ _initterm(__xt_a, __xt_z);#endif /* CRTDLL */#ifdef _DEBUG /* Dump all memory leaks */ if (!fExit &amp;&amp; _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) &amp; _CRTDBG_LEAK_CHECK_DF) &#123; fExit = 1;#ifndef CRTDLL __freeCrtMemory(); _CrtDumpMemoryLeaks();#endif /* CRTDLL */ &#125;#endif /* _DEBUG */ &#125; /* return to OS or to caller */ __FINALLY if (retcaller) _unlockexit(); /* unlock the exit code path */ __END_TRY_FINALLY if (retcaller) return; _C_Exit_Done = TRUE; _unlockexit(); /* unlock the exit code path */ __crtExitProcess(code);&#125; doexit()函数中Line 360 - 421是执行C++全局对象的析构函数。 C的清理工作在_initterm(xp_a, xp_z)和_initterm(xt_a, xt_z)中。 总结Multi-threaded Debug DLL(/MDd)选择此运行时，CRT库会在DLL中初始化，相关代码在crtdll.c中。 一、CRT堆 CRT（C RunTime）可以理解为Windows操作系统对C语言提供的一套支撑库，使得C程序通过C标准库函数就能与操作系统交互，而不需要调用windows API。普通CRT进程退出时，会首先以LIFO调用atexit注册的例程，执行完这些例程后，跟着清理CRT堆空间(而不是清理进程堆空间)，接着调用ExitProcess退出。注意了，不要以为进入ExitProcess后，进程就退掉，其实在进入ExitProcess后，将调用已加载的Dll的DllMainCRTStartup，这个函数以Process_Detach调用加载到进程的Dll的DllMain函数，之后，还会调用Dll的atexit注册例程，之后又是清理Dll自身的CRT堆空间。CRT堆就供new和malloc分配内存的进程堆空间。一个重要的概念，MainCRTStartup(DllMainCRTStartup)会调用main(DllMain)、atexit序列及清理CRT堆空间(静态连接为前提)。 二、Dll的atexit注册例程 其实，每个Dll模块都有自己的atexit stack，这个stack只有在Process_Detach时才会调用，每个Dll的atexit stack单独维护，并且与进程的atexit stack毫无关系。所以，请注意，凡是Dll内注册的atexit，不要引用非自身模块的变量或者非自身模块的CRT堆空间(静态连接为前提)，因为，Dll的atexit例程调用序列只按照自身Dll注册的序列调用，与外部的atexit序列不会产生任何关系。而引用的外部变量，很可能在Dll调用atexit注册的例程时已无效，特别是不要引用非自身CRT堆空间(静态连接为前提)。 三、自身CRT堆究竟是什么CRT堆是我们使用new、malloc的基础，CRT堆在可执行模块的入口点(MainCRTStartup、DllMainCRTStartup)使用HeapCreate创建。基于win32虚地址机制，CRT堆对象的地址与进程默认堆是在同一个线性地址空间内，使得进程可以通过加减内存地址轻松访问。 好，我们现在知道CRT堆的由来，那么问题来了，当可执行模块是静态连接(或连接到不同版本的CRT运行库)的时候，这份创建CRT堆的代码会存在于各个的可执行模块内部，于是，每个可执行模块在加载时都会创建自己的堆，我把这种堆称为自身CRT堆。 当这些拥有自身CRT堆的可执行模块加载到同一个进程空间内的时候，它们的堆空间虽然能交叉访问，但却不能交叉释放(A模块分配的内存不能在B模块内释放)，因为这些内存不是属于同一个堆的。同样，A模块分配的内存在A模块卸载后就变得无效了，因为A模块卸载会释放A模块自身CRT堆。当使用STL容器作模块间传递时，这些问题特别容易显现。想象一下容器内的元素来自不同的CRT堆，当容器析构时是怎么样的情况。 所以，当应用程序以可执行模块划分的时候，应该统一使用动态连接CRT运行库，并且，连接同一个版本的运行库。那么，什么是同一个版本的运行库呢？下一节展开分析。 话说回来，如果所有堆操作都使用进程默认堆，就不会出现问题了。不过，使用默认堆空间效率会比CRT堆低，因为CRT堆会预先保留提交内存以备使用，另外，使用进程默认堆，就不能使用new、delete创建销毁对象了。离开new，如何创建C++对象？^_^，使用placement new嘛。如何delete对象？先显式析构，再HeapFree吧。 程序一开始进入mainCRTStartup，执行栈检查 执行__tmainCRTStartup，进行运行前的初始化工作 C环境初始化 C++环境初始化，获取命令参数和环境变量，执行全局C++对象的构造函数 执行main函数 执行exit函数 exit函数中执行C++环境清理工作和执行全局C++对象的析构函数 执行C环境的清理工作 Multi-threaded Debug(/MTd)选择此运行时，则会在进入_tmain函数之前进行初始化。相关代码在crt0.c中。 程序一开始进入mainCRTStartup，执行栈检查 执行__tmainCRTStartup，进行运行前的初始化工作 初始化堆：_heap_init(1) 初始化多线程：_mtinit() 初始化I/O，_ioinit() 获取命令参数 获取环境变量 初始化C数据_cinit(TRUE)，这里面调用初始化（包括调用C++全局对象构造函数）_initterm_e( xi_a, xi_z )和_initterm( xc_a, xc_z )，这里和(/MDd)相同。 执行main函数 执行exit函数 exit函数中执行C++环境清理工作和执行全局C++对象的析构函数 执行C环境的清理工作 引用 C++全局变量构造函数的调用 C++全局对象的构造函数以及析构函数的调用 C/C++变量的生命周期 C++中变量的作用域与生命周期 main函数执行之前都干啥了—-C/C++运行时库剖析 静态对象、全局对象与程序的运行机制 静态全局变量和全局变量的区别 CRT Initialization CRT堆 CRT堆，这篇很重要","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://stanfordzhang.com/tags/Windows/"},{"name":"Visual C++ 2008","slug":"Visual-C-2008","permalink":"http://stanfordzhang.com/tags/Visual-C-2008/"},{"name":"C/C++ Runtime","slug":"C-C-Runtime","permalink":"http://stanfordzhang.com/tags/C-C-Runtime/"},{"name":"CRT","slug":"CRT","permalink":"http://stanfordzhang.com/tags/CRT/"},{"name":"mainCRTStartup","slug":"mainCRTStartup","permalink":"http://stanfordzhang.com/tags/mainCRTStartup/"}]},{"title":"curl -w/--write-out","slug":"curl-w-write-out","date":"2019-06-12T10:47:56.000Z","updated":"2019-06-12T11:27:39.739Z","comments":true,"path":"post/8722713.html","link":"","permalink":"http://stanfordzhang.com/post/8722713.html","excerpt":"概述curl功能很强大，但这里只介绍一个比较实用的命令： 1-w, --write-out FORMAT Use output FORMAT after completion 这个命令用于格式化输出请求结果。在测试网络连接状况、格式化输出上非常实用。","text":"概述curl功能很强大，但这里只介绍一个比较实用的命令： 1-w, --write-out FORMAT Use output FORMAT after completion 这个命令用于格式化输出请求结果。在测试网络连接状况、格式化输出上非常实用。 详解输出格式由普通字符串和任意数量的变量组成，输出变量需要按照%{variable_name}的格式，如果需要输出%，double一下即可，即%%，同时，\\n是换行，\\r是回车，\\t是TAB。curl会用合适的值来替代输出格式中的变量，所有可用变量如下： url_effective - 最终获取的url地址，尤其是当你指定给curl的地址存在301跳转，且通过-L继续追踪的情形。 http_code - http状态码，如200成功,301转向,404未找到,500服务器错误等。(The numerical response code that was found in the last retrieved HTTP(S) or FTP(s) transfer. In 7.18.2 the alias response_code was added to show the same info.) http_connect - The numerical code that was found in the last response (from a proxy) to a curl CONNECT request. (Added in 7.12.4) time_total - 总时间，按秒计。精确到小数点后三位。 （The total time, in seconds, that the full operation lasted. The time will be displayed with millisecond resolution.） time_namelookup - DNS解析时间,从请求开始到DNS解析完毕所用时间。(The time, in seconds, it took from the start until the name resolving was completed.) time_connect - 连接时间,从开始到建立TCP连接完成所用时间,包括前边DNS解析时间，如果需要单纯的得到连接时间，用这个time_connect时间减去前边time_namelookup时间。以下同理，不再赘述。(The time, in seconds, it took from the start until the TCP connect to the remote host (or proxy) was completed.) time_appconnect - 连接建立完成时间，如SSL/SSH等建立连接或者完成三次握手时间。(The time, in seconds, it took from the start until the SSL/SSH/etc connect/handshake to the remote host was completed. (Added in 7.19.0)) time_pretransfer - 从开始到准备传输的时间。(The time, in seconds, it took from the start until the file transfer was just about to begin. This includes all pre-transfer commands and negotiations that are specific to the particular protocol(s) involved.) time_redirect - 重定向时间，包括到最后一次传输前的几次重定向的DNS解析，连接，预传输，传输时间。(The time, in seconds, it took for all redirection steps include name lookup, connect, pretransfer and transfer before the final transaction was started. time_redirect shows the complete execution time for multiple redirections. (Added in 7.12.3)) time_starttransfer - 开始传输时间。在发出请求之后，Web 服务器返回数据的第一个字节所用的时间(The time, in seconds, it took from the start until the first byte was just about to be transferred. This includes time_pretransfer and also the time the server needed to calculate the result.) size_download - 下载大小。(The total amount of bytes that were downloaded.) size_upload - 上传大小。(The total amount of bytes that were uploaded.) size_header - 下载的header的大小(The total amount of bytes of the downloaded headers.) size_request - 请求的大小。(The total amount of bytes that were sent in the HTTP request.) speed_download - 下载速度，单位-字节每秒。(The average download speed that curl measured for the complete download. Bytes per second.) speed_upload - 上传速度,单位-字节每秒。(The average upload speed that curl measured for the complete upload. Bytes per second.) content_type - 就是content-Type，不用多说了，这是一个访问我博客首页返回的结果示例(text/html; charset=UTF-8)；(The Content-Type of the requested document, if there was any.) num_connects - Number of new connects made in the recent transfer. (Added in 7.12.3) num_redirects - Number of redirects that were followed in the request. (Added in 7.12.3) redirect_url - When a HTTP request was made without -L to follow redirects, this variable will show the actual URL a redirect would take you to. (Added in 7.18.2) ftp_entry_path - The initial path libcurl ended up in when logging on to the remote FTP server. (Added in 7.15.4) ssl_verify_result - ssl认证结果，返回0表示认证成功。( The result of the SSL peer certificate verification that was requested. 0 means the verification was successful. (Added in 7.19.0)) 注意： 若多次使用-w参数，按最后一个的格式输出。 在使用上面变量的时候，注意看后面小括号中的 Added in XXX，这个表示支持该变量curl所需的最低版本，查看curl版本使用curl -V。如果版本不够，curl会提示类似下面的错误。 1curl: unknown --write-out variable: 'redirect_url' curl -w举例检查一批URL的HTTP状态：cat url.txt|while read line; do curl -I $line -m 5 –connect-timeout 5 -o /dev/null -s -w “$line “%{http_code}”\\n”; done&gt;ok.txt 取URL返回状态码：curl -s -m 10 -o /dev/null -w %{http_code} https://www.baidu.com References curl -w,–write-out参数详解 Linux curl命令详解","categories":[],"tags":[]},{"title":"Flutter Development References","slug":"Flutter-Development-References","date":"2019-06-09T07:34:36.000Z","updated":"2019-06-11T10:46:13.384Z","comments":true,"path":"post/6bd6334f.html","link":"","permalink":"http://stanfordzhang.com/post/6bd6334f.html","excerpt":"","text":"Dart编程语言中文网 发布Android版APP Flutter】修改图标、应用名称、包名等 Flutter实战 Flutter中文网 FLUTTER WEB环境变量搭建及开发 flutter-desktop-embedding","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://stanfordzhang.com/tags/Flutter/"},{"name":"Dart","slug":"Dart","permalink":"http://stanfordzhang.com/tags/Dart/"},{"name":"Android","slug":"Android","permalink":"http://stanfordzhang.com/tags/Android/"}]},{"title":"Use protobuf in Flutter","slug":"Use-protobuf-in-Flutter","date":"2019-06-08T10:44:40.000Z","updated":"2019-06-08T11:06:31.102Z","comments":true,"path":"post/642e1725.html","link":"","permalink":"http://stanfordzhang.com/post/642e1725.html","excerpt":"概述在Flutter项目中使用protobuf，macOS上环境配置及Flutter工程配置。","text":"概述在Flutter项目中使用protobuf，macOS上环境配置及Flutter工程配置。 步骤下载protobuf：https://github.com/protocolbuffers/protobuf/releases这里以protoc-3.8.0-osx-x86_64.zip为例或者： 1brew install protobuf 安装dart 12brew tap dart-lang/dartbrew install dart dart安装好后，就有pub命令了。 安装protoc_plugin 1pub global activate protoc_plugin 这个protoc_plugin一定要安装，protoc默认不支持dart.将protoc-gen-dart添加到path在~/.bash_profile或~/.zshrc添加 1export \"$PATH:$PWD/.pub-cache/bin\" 如果没有添加到PATH也可以在protoc参数是增加 1protoc --dart_out=. test.proto --plugin ~/.pub-cache/bin/protoc-gen-dart 安装好后，就有protoc-gen-dart命令了。如果没有安装以上工具，使用–dart_out编译时会报错 12protoc-gen-dart: program not found or is not executable--dart_out: protoc-gen-dart: Plugin failed with status code 1. 在Flutter项目中引入protobuf库 在pubspec.ymal中添加以下依赖 1protobuf: ^0.13.12 在编译官方示例过程addressbook.proto过程，如果报错找不到google/protobuf/timestamp.pb.dart则需要单独编译下载包里的protoc-3.8.0-osx-x86_64/include/google/protobuf/timestamp.proto 1protoc -I=~/Downloads/protoc-3.8.0-osx-x86_64/include/ --dart_out=. google/protobuf/timestamp.proto 如果缺少其他文件，可类似处理。 Reference 在Flutter中使用protobuf","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://stanfordzhang.com/tags/Flutter/"},{"name":"protobuf","slug":"protobuf","permalink":"http://stanfordzhang.com/tags/protobuf/"}]},{"title":"Tomcat内存溢出解决办法","slug":"Tomcat内存溢出解决办法","date":"2019-06-07T09:52:18.000Z","updated":"2019-06-07T09:59:15.239Z","comments":true,"path":"post/c5ce665c.html","link":"","permalink":"http://stanfordzhang.com/post/c5ce665c.html","excerpt":"概述常见的tomcat 内存溢出有下面三种情况： OutOfMemoryError： Java heap space OutOfMemoryError： PermGen space OutOfMemoryError： unable to create new native thread","text":"概述常见的tomcat 内存溢出有下面三种情况： OutOfMemoryError： Java heap space OutOfMemoryError： PermGen space OutOfMemoryError： unable to create new native thread NEXT主题添加Google AdSensejvm参数知道：-Xms：初始值-Xmn：最小值-Xmx：最大值 linux 配置在catalina.sh 中，找到cygwin=false 行，在它上面 加上下面的一段代码： JAVA_OPTS=”-Xms1024m -Xmx1024m”JAVA_OPTS=”$JAVA_OPTS -server -XX:PermSize=512m -XX:MaxPermSize=512m” window 配置在catalina.bat中找到 setlocal ，在其上面 加上下面的代码： set JAVA_OPTS=-server -Xms1024m -Xmx2048m -XX:PermSize=512m -XX:MaxPermSize=2048m 参数说明：-server:一定要作为第一个参数，在多个CPU时性能佳-Xms：初始Heap大小，使用的最小内存,cpu性能高时此值应设的大一些-Xmx：Java heap最大值，使用的最大内存-XX:PermSize:设定内存的永久保存区域-XX:MaxPermSize:设定最大内存的永久保存区域-XX:MaxNewSize:+XX:AggressiveHeap 会使得 Xms没有意义。这个参数让jvm忽略Xmx参数,疯狂地吃完一个G物理内存,再吃尽一个G的swap。-Xss：每个线程的Stack大小-verbose:gc 现实垃圾收集信息-Xloggc:gc.log 指定垃圾收集日志文件-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一-XX:+UseParNewGC ：缩短minor收集的时间-XX:+UseConcMarkSweepGC ：缩短major收集的时间 提示：此选项在Heap Size 比较大而且Major收集时间较长的情况下使用更合适 * 注意，linux下有单引号，win下不用，如果加上单引号，tomcat根本起不来。 Reference 解决 tomcat 内存溢出解决的办法","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://stanfordzhang.com/tags/Java/"}]},{"title":"Hexo博客添加Google AdSense","slug":"Add Google AdSense to Hexo with NEXT theme","date":"2019-05-21T08:13:30.000Z","updated":"2019-06-08T10:49:05.253Z","comments":true,"path":"post/3a06bb38.html","link":"","permalink":"http://stanfordzhang.com/post/3a06bb38.html","excerpt":"概述主要内容包括： Hexo博客，使用hexo-theme-next主题，添加Google AdSense。 添加ads.txt SEO优化之title SEO优化之添加robots.txt SEO优化之添加sitemap SEO优化之配置Google Search Console","text":"概述主要内容包括： Hexo博客，使用hexo-theme-next主题，添加Google AdSense。 添加ads.txt SEO优化之title SEO优化之添加robots.txt SEO优化之添加sitemap SEO优化之配置Google Search Console NEXT主题添加Google AdSense 参考[1][2] 注册Google AdSense账号，方法请自行搜索 注册完账号后，将AdSense里的JavaSrcipt脚本添加至NEXT主题模板里 新建 themes/next/layout/_custom/google_adsense.swig，将 AdSense 上的JavaScript代码粘贴进去 编辑 themes/hexo-theme-next/layout/_layout.swig 文件，在head元素里增加如下代码： 123&lt;!-- Google AdSense start --&gt;&#123;% include '_custom/google_adsense.swig' %&#125;&lt;!-- Google AdSense end --&gt; 添加ads.txt 参考[3][4] 授权数字卖方 (ads.txt) 是一项 IAB 计划，可帮助确保您的数字广告资源只通过您认定为已获得授权的卖家（如 AdSense）销售。创建自己的 ads.txt 文件后，您可以更好地掌控允许谁在您的网站上销售广告，并可防止向广告客户展示仿冒广告资源。添加方法参考[3][4]。 SEO优化之title 参考[5] 1&#123;% block title %&#125;&#123;&#123; title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;&#123;% if theme.index_with_subtitle and subtitle %&#125; – &#123;&#123; subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; 在themes/hexo-theme-next/layout/index.swig文件里的title内添加，也可以是其他的关键字，更有利于详细的描述网站，便于搜索引擎推荐。 SEO优化之添加robots.txt 参考[5] SEO优化之添加sitemap 参考[5] SEO优化之配置Google Search Console 参考[6][7] 参考文章中是老版本Search Console，这里使用新版本。网址：https://www.google.com/webmasters/ 在添加资源过程中有两种方式，如图所示： 图中左侧是新方法，但我没有测试成功，大概原因是Github Pages是使用CNAME来绑定域名的。本例使用右侧的老方法，输入域名之后，会下载一个html文件放在网站根目录，所下图所示：这个html是不需要渲染的，所以在_config.xml文件中配置skip_render，添加下载的html文件。验证通过后，进入Search Console，可以添加Sitemap、URL检查等操作，参考[7]。 FAQ 参考[9][10][11] Reference Hexo博客添加Google AdSense hexo 中加入 AdSense 广告服务的方法 使用 ads.txt 声明授权卖方 查找发布商 ID Hexo网站优化之SEO Hexo Seo优化让你的博客在google搜索排名第一 Google Search Console验证您的网站所有权 Hexo博客Next主题SEO优化方法 hexo链接持久化终极解决之道 Hexo渲染时排除部分文件或目录 Hexo版本升级和Next主题升级之坑","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://stanfordzhang.com/tags/Hexo/"},{"name":"hexo theme next","slug":"hexo-theme-next","permalink":"http://stanfordzhang.com/tags/hexo-theme-next/"},{"name":"Google AdSense","slug":"Google-AdSense","permalink":"http://stanfordzhang.com/tags/Google-AdSense/"},{"name":"SEO","slug":"SEO","permalink":"http://stanfordzhang.com/tags/SEO/"},{"name":"Google Search Console","slug":"Google-Search-Console","permalink":"http://stanfordzhang.com/tags/Google-Search-Console/"}]},{"title":"Install Nessus on Kali Linux","slug":"Install Nessus on Kali Linux","date":"2018-05-21T11:46:21.000Z","updated":"2019-06-07T09:21:35.491Z","comments":true,"path":"post/e8fcbb5.html","link":"","permalink":"http://stanfordzhang.com/post/e8fcbb5.html","excerpt":"Nessus是什么？ Nessus号称是世界上最流行的漏洞扫描程序，全世界有超过75000个组织在使用它。该工具提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。Nessus不同于传统的漏洞扫描软件，Nessus可同时在本机或远程操作，进行系统的漏洞分析扫描。","text":"Nessus是什么？ Nessus号称是世界上最流行的漏洞扫描程序，全世界有超过75000个组织在使用它。该工具提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。Nessus不同于传统的漏洞扫描软件，Nessus可同时在本机或远程操作，进行系统的漏洞分析扫描。 下载并安装根据不同的OS下载不同的版本，Kali Linux下载debian 6版本的Nessus。 https://www.tenable.com/downloads/nessus 安装命令： 123456789101112root@kali:~/Documents# dpkg -i Nessus-7.1.0-debian6_amd64.debSelecting previously unselected package nessus.(Reading database ... 335227 files and directories currently installed.)Preparing to unpack Nessus-7.1.0-debian6_amd64.deb ...Unpacking nessus (7.1.0) ...Setting up nessus (7.1.0) ...Unpacking Nessus Core Components... - You can start Nessus by typing /etc/init.d/nessusd start - Then go to https://kali:8834/ to configure your scannerProcessing triggers for systemd (238-4) ... 显示到这里就安装成功了！ 启动Nessus 1/etc/init.d/nessusd start 激活注册领取免费版本的激活码，领取之后会发送到邮件，注意查看邮箱。 https://www.tenable.com/products/nessus/activation-code 使用激活码激活 1/opt/nessus/sbin/nessuscli fetch --register 0BB7-F54A-60D7-FCE7-976E 激活过程中会下载安装Plugins，稍作等待。 添加账号这里都使用默认配置： 123456789101112131415161718192021root@kali:~/Documents# /opt/nessus/sbin/nessuscli adduser root[Mon May 21 06:42:52 2018][2752.1] _qdb_open:/opt/nessus/var/nessus/plugins-desc.db: Invalid table of contentsLogin password:Login password (again):Do you want this user to be a Nessus 'system administrator' user (can upload plugins, etc.)? (y/n) [n]: yUser rules----------nessusd has a rules system which allows you to restrict the hoststhat root has the right to test. For instance, you may wanthim to be able to scan his own host only.Please see the Nessus Command Line Reference for the rules syntaxEnter the rules for this user, and enter a BLANK LINE once you are done :(the user can have an empty rules set)Login : rootPassword : ***********This user will have 'system administrator' privileges within the Nessus serverIs that ok? (y/n) [n]: yUser added 访问控制界面重启Nessus服务 1/etc/init.d/nessusd restart 打开浏览器访问，默认端口是8834。 https://10.98.53.137:8834 References 《Kali Linux渗透测试技术详解》","categories":[],"tags":[{"name":"Kali Linux","slug":"Kali-Linux","permalink":"http://stanfordzhang.com/tags/Kali-Linux/"},{"name":"Nessus","slug":"Nessus","permalink":"http://stanfordzhang.com/tags/Nessus/"},{"name":"Security","slug":"Security","permalink":"http://stanfordzhang.com/tags/Security/"}]},{"title":"XCode设置Build Number自增","slug":"XCode设置Build-Number自增","date":"2017-11-30T09:46:21.000Z","updated":"2019-06-07T09:21:35.497Z","comments":true,"path":"post/c7253149.html","link":"","permalink":"http://stanfordzhang.com/post/c7253149.html","excerpt":"CocoaPods是什么？ 在提交iOS应用时，相同的Build Number是无法重复上传的。如果每次都要手动修改版本号，比较低效和容易出错。所以这里介绍一种自动增加Build Number的方法。","text":"CocoaPods是什么？ 在提交iOS应用时，相同的Build Number是无法重复上传的。如果每次都要手动修改版本号，比较低效和容易出错。所以这里介绍一种自动增加Build Number的方法。 References https://crunchybagel.com/auto-incrementing-build-numbers-in-xcode/","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://stanfordzhang.com/tags/iOS/"},{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"},{"name":"XCode","slug":"XCode","permalink":"http://stanfordzhang.com/tags/XCode/"}]},{"title":"macOS设置不在Dock上显示App图标","slug":"macOS设置不在Dock上显示App图标","date":"2016-10-09T08:43:30.000Z","updated":"2019-06-07T09:21:35.499Z","comments":true,"path":"post/a4b8d061.html","link":"","permalink":"http://stanfordzhang.com/post/a4b8d061.html","excerpt":"","text":"在Info.Plist里设置：LSUIElement是以Agent的方法启动。不在Dock上显示图标，但会显示窗口。LSBackgroundOnly变成后台进程，不在Dock上显示图标，也不会显示窗口。 TransformProcessType[NSApp setActivationPolicy: NSApplicationActivationPolicyAccessory];以上两个没有研究。 Reference: https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/20001431-113253 http://stackoverflow.com/questions/6796028/start-a-gui-process-in-mac-os-x-without-dock-icon/9220840 http://stackoverflow.com/questions/620841/how-to-hide-the-dock-icon","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"Git代理设置（macOS）","slug":"Git代理设置（macOS）","date":"2016-08-29T08:41:50.000Z","updated":"2019-06-07T09:21:35.489Z","comments":true,"path":"post/175d5c0d.html","link":"","permalink":"http://stanfordzhang.com/post/175d5c0d.html","excerpt":"","text":"最近要在https://chromium.googlesource.com/ Checkout点代码，但该网站被GFW墙了。无奈只能走野路子。 使用socks5通道： 首先通过如下命令登录一台未被墙的服务器： ssh root@IP地址或域名 -D 端口修改Git的配置（~/.gitconfig），新增如下行： [http]proxy = socks5://127.0.0.1:\b端口这样Git将走代理通道。 Reference:1：为Git配置代理","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"iOS/macOS签名证书类型","slug":"iOS-macOS签名证书类型","date":"2016-08-24T08:38:26.000Z","updated":"2019-06-07T09:21:35.498Z","comments":true,"path":"post/a8003ca5.html","link":"","permalink":"http://stanfordzhang.com/post/a8003ca5.html","excerpt":"","text":"Reference https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/AppDistributionGuide/MaintainingCertificates/MaintainingCertificates.html#//apple_ref/doc/uid/TP40012582-CH31-SW41 http://stackoverflow.com/questions/13196291/difference-between-mac-developer-and-3rd-party-mac-developer-application","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://stanfordzhang.com/tags/iOS/"},{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"Kali Linux 2016.1 中科大源","slug":"Kali-Linux-2016-1-中科大源","date":"2016-08-22T08:35:41.000Z","updated":"2019-06-07T09:21:35.490Z","comments":true,"path":"post/ab7afda6.html","link":"","permalink":"http://stanfordzhang.com/post/ab7afda6.html","excerpt":"","text":"修改 /etc/apt/sources.list1234#kali官方源deb http://http.kali.org/kali kali-rolling main non-free contrib#中科大的源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib 依次执行下面命令：123apt-get update &amp; apt-get upgradeapt-get dist-upgradereboot","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://stanfordzhang.com/tags/随笔/"}]},{"title":"How To Set Up SSH Tunneling on a VPS","slug":"How-To-Set-Up-SSH-Tunneling-on-a-VPS","date":"2016-06-01T08:34:03.000Z","updated":"2019-06-07T09:21:35.489Z","comments":true,"path":"post/26d5a5c1.html","link":"","permalink":"http://stanfordzhang.com/post/26d5a5c1.html","excerpt":"","text":"How To Set Up SSH Tunneling on a VPS使用SSH隧道进行翻墙。 ##Reference: https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-tunneling-on-a-vps","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://stanfordzhang.com/tags/随笔/"}]},{"title":"Mac OS X快速安装Apache Thrift","slug":"Mac-OS-X快速安装Apache-Thrift","date":"2016-05-26T10:55:07.000Z","updated":"2019-06-07T09:21:35.495Z","comments":true,"path":"post/c2cdf3b4.html","link":"","permalink":"http://stanfordzhang.com/post/c2cdf3b4.html","excerpt":"介绍Thrift 最初由Facebook开发，而后捐献给Apache，目前已广泛应用于业界。Thrift 正如其官方主页介绍的，“是一种可扩展、跨语言的服务开发框架”。简而言之，它主要用于各个服务之间的RPC通信，其服务端和客户端可以用不同的语言来开发。只需要依照IDL（Interface Description Language）定义一次接口，Thrift工具就能自动生成 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml等语言的代码。","text":"介绍Thrift 最初由Facebook开发，而后捐献给Apache，目前已广泛应用于业界。Thrift 正如其官方主页介绍的，“是一种可扩展、跨语言的服务开发框架”。简而言之，它主要用于各个服务之间的RPC通信，其服务端和客户端可以用不同的语言来开发。只需要依照IDL（Interface Description Language）定义一次接口，Thrift工具就能自动生成 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml等语言的代码。 安装Thrift的安装还是有些繁琐的，跟着官方文档的走就可以。如果你是Mac OS X， 这里有更方便的方法。brew install boostbrew install libeventbrew install thriftgem install thrift – –with-cppflags=’-D_FORTIFY_SOURCE=0’ 不过注意上述方法默认安装的最新版。 QAError: The brew link step did not complete successfullyThe formula built, but is not symlinked into /usr/localYou can try again using `brew link thrift’ 如果报以上错误，再手动运行：brew link thrift 即可。 * Reference https://wuchong.me/blog/2015/10/07/thrift-induction/ https://diwakergupta.github.io/thrift-missing-guide/ http://thrift-tutorial.readthedocs.io/en/latest/index.html http://www.jianshu.com/p/0f4113d6ec4b","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"Linux/OSX 命令输入操作快捷键","slug":"Linux-OSX-命令输入操作快捷键","date":"2016-05-17T10:54:26.000Z","updated":"2019-06-07T09:21:35.492Z","comments":true,"path":"post/1f6fd35e.html","link":"","permalink":"http://stanfordzhang.com/post/1f6fd35e.html","excerpt":"","text":"ctrl + w —往回删除一个单词，光标放在最末尾ctrl + k —往前删除到末尾，光标放在最前面（可以使用ctrl+a）ctl + u 删除光标以前的字符ctl + k 删除光标以后的字符ctl + a 移动光标至的字符头ctl + e 移动光标至的字符尾ctl + l 清屏 ctrl + r命令历史，继续按这个快捷键可以向前翻","categories":[],"tags":[]},{"title":"Linux/OSX 统计文件个数命令","slug":"Linux-OSX-统计文件个数命令","date":"2016-05-17T10:52:28.000Z","updated":"2019-06-07T09:21:35.493Z","comments":true,"path":"post/4a20c7a3.html","link":"","permalink":"http://stanfordzhang.com/post/4a20c7a3.html","excerpt":"","text":"命令如下：1find &lt;目录&gt; -type f | wc -l 根据目录路径，显示文件个数，不包括目录。 例如：统计全盘文件个数：1find / -type f | wc -l","categories":[],"tags":[]},{"title":"Mac OS X 快速复制（拷贝）文件（夹）路径","slug":"Mac-OS-X-快速复制（拷贝）文件（夹）路径","date":"2016-04-13T14:17:02.000Z","updated":"2019-06-07T09:21:35.494Z","comments":true,"path":"post/e3989891.html","link":"","permalink":"http://stanfordzhang.com/post/e3989891.html","excerpt":"在使用Mac OS X的\b过程中，如果有一个文件所在的目录层次很深，想要拷贝文件路径是麻烦事儿。本文介绍一种通过Finder右键菜单项来复制文件路径的方法，如果哪个朋友有更好的方法麻烦告知，在此谢过！","text":"在使用Mac OS X的\b过程中，如果有一个文件所在的目录层次很深，想要拷贝文件路径是麻烦事儿。本文介绍一种通过Finder右键菜单项来复制文件路径的方法，如果哪个朋友有更好的方法麻烦告知，在此谢过！ 在Launchpad里启动Automator。 创建一个新的服务（Service）。选项如下图所示： \b最后保存为Copy Path： \b 这样就完成了Finder右键菜单项的制作，试试吧~ Reference: http://osxdaily.com/2013/06/19/copy-file-folder-path-mac-os-x/","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"CocoaPods安装和使用教程","slug":"CocoaPods安装和使用教程","date":"2016-04-12T14:14:00.000Z","updated":"2019-06-07T09:21:35.488Z","comments":true,"path":"post/902b1754.html","link":"","permalink":"http://stanfordzhang.com/post/902b1754.html","excerpt":"CocoaPods是什么？ 通常在开发iOS/OSX应用时，经常使用到一些第三方开源库，比如JSONKit，AFNetWorking，OpenSSL，Boost等。这些库下载、版本更新管理相当麻烦和费时，尤其是C/C++相关库，还需要编译，编译时还有各种各样的库依赖。那有没有类似于Python中的PIP/easy_install这样的包（库）管理工具呢？ 本文将介绍一个开发iOS/OSX时经常用到的包管理工具CocoaPods。 官方网址：https://cocoapods.org/","text":"CocoaPods是什么？ 通常在开发iOS/OSX应用时，经常使用到一些第三方开源库，比如JSONKit，AFNetWorking，OpenSSL，Boost等。这些库下载、版本更新管理相当麻烦和费时，尤其是C/C++相关库，还需要编译，编译时还有各种各样的库依赖。那有没有类似于Python中的PIP/easy_install这样的包（库）管理工具呢？ 本文将介绍一个开发iOS/OSX时经常用到的包管理工具CocoaPods。 官方网址：https://cocoapods.org/ 安装CocoaPods安装CocoaPods，需要使用Ruby环境，通常Mac OS X已经自带Ruby。在终端下运行如下命令： 1$ sudo gem install cocoapods 安装失败？是的，因为默认安装源被GFW了。这里需要更改成淘宝的源： 12gem sources --remove https://rubygems.org/ // 删除原来的gem sources -a https://ruby.taobao.org/ // 增加淘宝的源，这里注意淘宝已经废弃http的源，统一成了https 查看源： 12345gem sources -l *** CURRENT SOURCES *** https://ruby.taobao.org/ 现在执行： 1sudo gem install cocoapods 等一会，是不是安装成功了~ 使用CocoaPods首先搜索需要使用的库是否支持CocoaPods（这里以AFNetworking为例）： 这里可以看到很多个带有AFNetworking关键字的库，第一个是我们要找的。 接下来创建一个示例工程pod_demo，同时在工程文件pod_demo.xcodeproj同一目录下创建Podfile文本文件： 并输入如下内容： 12platform :osx, '10.9'pod 'AFNetworking', '~&gt; 2.6.3' 第一行解释： 因为示例工程是OSX平台的，所有platform是osx版本。如果是用于iOS，Platform是可以写成： 1platform :ios, '8.0' 在安装过程中会检测当前库版本是否适用于指定的系统版本，如果不适用，会报如下异常： \b不同的AFNetworking对应不同的系统版本【2】：\b第二行解释：‘&gt; 0.1’ 大于0.1的版本‘&gt;= 0.1’ 大于等于0.1的版本‘&lt; 0.1’ 小于0.1的版本‘&lt;= 0.1’ 小于等于0.1的版本‘~&gt; 0.1.2’ 0.1.2到0.2之间的版本，不包括0.2及\b更高版本‘~&gt; 0.1’ 0.1到1.0之间的版本，不包括1.0及更高版本‘~&gt; 0’ 0及更高版本，相当于所有版本 接下来终端切换到Podfile所在目录，安装库： 1pod install 这时你会发现目录下多了几个文件（夹）：pod_demo.xcworkspace、Podfile.lock、Pods，这些都是CocoaPods生成的。目录结构如下： \b\b上图是安装成功界面，请注意最后绿字那一行：关闭XCode，并打开pod_demo.xcworkspace。这时用XCode打开pod_demo.xcworkspace，在代码中就能正常使用AFNetworing库了。 注：使用CocoaPods安装库后，要打开xcworkspace而不是xcodeproj了。## 补充内容如果已经有Podfile，需要更新新版本，使用：1pod update Reference:https://cocoapods.org/https://github.com/AFNetworking/AFNetworking","categories":[],"tags":[]},{"title":"Mac OS X上开发和使用动态链接库/dylib/共享库","slug":"Mac-OS-X上开发和使用动态链接库-dylib-共享库","date":"2016-04-11T13:48:13.000Z","updated":"2019-06-07T09:21:35.496Z","comments":true,"path":"post/9a8573bf.html","link":"","permalink":"http://stanfordzhang.com/post/9a8573bf.html","excerpt":"在OS X上开发应用通常会用到dylib动态链接库，使用XCode开发及调用一个dylib还是比较容易的，通常的做法使用dlopen（类似于Windows上的LoadLibrary）加载dylib，使用dlsym（类似GetProcAddress）找到导出接口，然后调用，最后dlclose（类似FreeLibrary）之即可。这个方法和Linux上使用共享库的方式是一样的，这里就不作介绍了。 本文介绍一种更加方便的方法，通过设置几个编译选项，运行时系统自动加载dylib，使用时只需要调用即可。以下是示例步骤。","text":"在OS X上开发应用通常会用到dylib动态链接库，使用XCode开发及调用一个dylib还是比较容易的，通常的做法使用dlopen（类似于Windows上的LoadLibrary）加载dylib，使用dlsym（类似GetProcAddress）找到导出接口，然后调用，最后dlclose（类似FreeLibrary）之即可。这个方法和Linux上使用共享库的方式是一样的，这里就不作介绍了。 本文介绍一种更加方便的方法，通过设置几个编译选项，运行时系统自动加载dylib，使用时只需要调用即可。以下是示例步骤。 一、创建dylib工程创建dylib工程dylib_demo。 二、参数选择这里以导出C++类接口为例。 三、配置编译选项可以在dylib的Build Phases里看到Installataion Diectory（INSTALL_PATH）这个选项，默认是/usr/local/lib。这个意思是指可执行程序在自动加载时去哪里找这个dylib。可以使用otool进行查看（如下图）。 第一行显示的就是dylib所在的路径：/usr/local/lib/libdylib_demo.dylib。这是系统目录，调用程序会去这个目录找。如果不把dylib拷贝到这个目录，程序将无法运行。发布一个程序时，还要将自用库拷贝到系统目录？这是不合理的。 这里将Installation Directory改成@loader_path/../Frameworks，以相对目录查找dylib。下图是otool显示。@loader_path的意思相对load这个dylib的模块所在的路径找dylib所在的目录。 Installation Directory (INSTALL_PATH) 详解： @executable_path 表示可执行程序所在的目录. 比如 /path/foo.app/Contents/MacOS/。 @loader_path 表示每一个被加载的 binary（包括App, dylib, framework等）所在的目录。 @rpath 和前面两个不同, 它只是一个保存着一个或多个路径的变量。在 app中设置 Runpath Search Paths（对应了@rpath）。 四、创建调用app创建名为caller_demo的app。 参数设置 五、设置链接到dylib在app的Build Phases的Link Binary With Libraries里增加刚刚创建的dylib。 如果列表里没有点击右下角的Add Other在目录里找。 也可以在Finder里拖拽dylib到Link Binary With Libraries里。 六、拷贝dylib至目标目录这里app包结构包结构里还没有这个dylib，运行时还是找不着。在Build Phases里点加号，新增Copy Files Phase，将dylib拷贝到Frameworks目录下，以便loader可以找到。 这里为什么是Frameworks目录，是因为设置INSTALL_PATH为@loader_path/../Frameworks。 也可以设置为其他目录，比如INSTALL_PATH为@loader_path/../dll，那Copy Files时，就要放到dll目录，如果下拉列表没有相应目录，可以下拉选Frameworks，然后在Subpath里填../dll这个相对路径，XCode会自动创建一个Frameworks同级目录dll。 \b \b \b 七、调用比如在AppDelegate.m文件里调用，因为是使用C++类，所以要将文件扩展名改为.mm，如果是使用标准C、ObjC接口，则不用改。 八、结语可以看到，以上方法使用比较方便，在开发过程中配置好XCode，一键编译。 调用时可以像静态库一样使用，省时省力。 Reference: http://www.tanhao.me/pieces/1361.html/ https://wincent.com/wiki/@executable_path,_@load_path_and_@rpath","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://stanfordzhang.com/tags/macOS/"}]},{"title":"基于腾讯云自建Blog-WordPress+CentOS+Nginx","slug":"基于腾讯云自建Blog-WordPress-CentOS-Nginx","date":"2016-04-07T13:13:30.000Z","updated":"2019-06-07T09:21:35.500Z","comments":true,"path":"post/99172a83.html","link":"","permalink":"http://stanfordzhang.com/post/99172a83.html","excerpt":"","text":"搭建步骤 申请云服务器 设置云服务器安装组，打开80端口。如果要访问安装在云服务器的MySQL，还要打开3306端口； 参考【1】安装Nginx/MySQL/PHP。如果使用香港云数据库CDB，无法在外网登录管理； 参考【2】安装WordPress； 因为GWF的原因，基于WordPress的网站加载比较慢，这里推荐两个插件： Google字体相关：Useso take over Google（重定向到360网站卫士的镜像）； Gravatar相关：WP-DuoShuo-Gravatar（重写向到多说的镜像）。 固定链接设置【3】。如果是使用默认固定链接，可以不设置。 接下来就可以愉快的写作了。 Reference: 软件安装：https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-on-centos-6 WordPress安装：https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-nginx-on-centos-6–2 固定链接设置：http://nginxlibrary.com/wordpress-permalinks/","categories":[],"tags":[]}]}